 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\MainActivity.kt --- 
package com.bwc.tul

import android.content.Context
import android.util.Log
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.fragment.app.FragmentActivity
import androidx.activity.viewModels
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.lifecycle.lifecycleScope
import com.bwc.tul.audio.AudioHandler
import androidx.activity.compose.setContent
import com.bwc.tul.audio.AudioPlayer.Companion.TAG
import com.bwc.tul.ui.dialog.SettingsDialog
import com.bwc.tul.ui.dialog.UserSettingsDialogFragment
import com.bwc.tul.ui.TranslationAdapter
import com.bwc.tul.viewmodel.MainViewModel
import com.bwc.tul.viewmodel.MainViewModelFactory
import kotlinx.coroutines.launch
import java.io.File

class MainActivity : FragmentActivity(),
    UserSettingsDialogFragment.UserSettingsListener,
    SettingsDialog.DevSettingsListener {

    private val viewModel: MainViewModel by viewModels {
        MainViewModelFactory(
            application,
            AudioHandler(
                context = applicationContext,
                onAudioChunk = { viewModel.sendAudio(it) }
            )
        )
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            val uiState by viewModel.uiState.collectAsState()
            MainScreen(viewModel = viewModel)
        }

        lifecycleScope.launch {
            viewModel.events.collect { event ->
                when (event) {
                    is MainViewModel.ViewEvent.ShowToast -> showToast(event.message)
                    is MainViewModel.ViewEvent.ShowError -> showError(event.message)
                    is MainViewModel.ViewEvent.ShareLogFile -> shareLogFile(event.uri)
                    is MainViewModel.ViewEvent.ShowUserSettings -> showUserSettings()
                    is MainViewModel.ViewEvent.ShowDevSettings -> showDevSettings()
                    is MainViewModel.ViewEvent.ExportLogsCompleted -> {
                        // Handle the export logs completed event
                        showToast("Web Socket Logs Exported") }
                    }
            }
        }
    }

    override fun onRequestPermission() {
        viewModel.handleEvent(MainViewModel.UserEvent.RequestPermission)
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun shareLogFile(uri: android.net.Uri) {
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
        startActivity(Intent.createChooser(shareIntent, "Share log file"))
    }

    private fun showUserSettings() {
        val dialog = UserSettingsDialogFragment()
        dialog.show(supportFragmentManager, "UserSettingsDialog")
    }

    private fun showDevSettings() {

        val models = listOf(
            "gemini-2.5-flash-preview-native-audio-dialog",
            "gemini-2.0-flash-live-001",
            "gemini-2.5-flash-live-preview"
        )
        val prefs = getSharedPreferences("BwctransPrefs", Context.MODE_PRIVATE)
        SettingsDialog(this, this, prefs, models).show()
    }

    override fun onForceConnect() {
        viewModel.handleEvent(MainViewModel.UserEvent.ConnectClicked)
    }

    override fun onSettingsSaved() {
        viewModel.handleEvent(MainViewModel.UserEvent.SettingsSaved)
    }

    override fun onShareLog() {
        viewModel.handleEvent(MainViewModel.UserEvent.ShareLogRequested)
    }

    override fun onClearLog() {
        viewModel.handleEvent(MainViewModel.UserEvent.ClearLogRequested)
    }

    override fun onExportLogsComplete(file: File) {
        // Handle the exported log file (e.g., share it).
        viewModel.handleEvent(MainViewModel.UserEvent.ExportLogsCompleted)

        val uri: android.net.Uri? = try {
            androidx.core.content.FileProvider.getUriForFile(
                this,
                "${packageName}.provider", // Make sure this matches your FileProvider authority
                file
            )
        } catch (e: Exception) {
            showError("Error creating log file URI for sharing: ${e.message}")
            Log.e(TAG, "Error creating log file UIR", e)
            null
        }

        uri?.let {
            val shareIntent = Intent(Intent.ACTION_SEND).apply {
                type = "text/plain"
                putExtra(Intent.EXTRA_STREAM, it)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }
            startActivity(Intent.createChooser(shareIntent, "Share WebSocket log file"))
        } ?: run {
            showToast("Couldn't create log file for sharing.")
        }
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\audio\AudioHandler.kt --- 
package com.bwc.tul.audio

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.media.audiofx.AcousticEchoCanceler
import android.media.audiofx.AutomaticGainControl
import android.media.audiofx.NoiseSuppressor
import android.os.Process
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

class AudioHandler(
    private val context: Context,
    private val onAudioChunk: (ByteArray) -> Unit // Changed to pass ByteArray
) {

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private val audioScope = CoroutineScope(Dispatchers.IO)

    private var noiseSuppressor: NoiseSuppressor? = null
    private var agc: AutomaticGainControl? = null
    private var aec: AcousticEchoCanceler? = null

    companion object {
        private const val SAMPLE_RATE = 16000
        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT
        private const val TAG = "AudioHandler"
    }

    fun startRecording() {
        if (isRecording) return

        val bufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)
        if (bufferSize == AudioRecord.ERROR_BAD_VALUE) {
            Log.e(TAG, "Invalid AudioRecord parameters.")
            return
        }

        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "RECORD_AUDIO permission not granted.")
            return
        }

        audioRecord = AudioRecord.Builder()
            .setAudioSource(MediaRecorder.AudioSource.MIC)
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AUDIO_FORMAT)
                    .setSampleRate(SAMPLE_RATE)
                    .setChannelMask(CHANNEL_CONFIG)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize)
            .build()

        val sessionId = audioRecord?.audioSessionId ?: 0
        if (sessionId != 0) {
            if (NoiseSuppressor.isAvailable()) {
                noiseSuppressor = NoiseSuppressor.create(sessionId).apply { enabled = true }
                Log.d(TAG, "NoiseSuppressor enabled.")
            }
            if (AutomaticGainControl.isAvailable()) {
                agc = AutomaticGainControl.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AutomaticGainControl enabled.")
            }
            if (AcousticEchoCanceler.isAvailable()) {
                aec = AcousticEchoCanceler.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AcousticEchoCanceler enabled.")
            }
        }

        audioRecord?.startRecording()
        isRecording = true
        Log.d(TAG, "Recording started.")

        audioScope.launch {
            Process.setThreadPriority(Process.THREAD_PRIORITY_AUDIO)
            val audioBuffer = ByteArray(bufferSize)
            while (isActive && isRecording) {
                val readResult = audioRecord?.read(audioBuffer, 0, audioBuffer.size) ?: 0
                if (readResult > 0) {
                    // Pass the raw byte array directly
                    onAudioChunk(audioBuffer.copyOf(readResult))
                }
            }
        }
    }

    fun stopRecording() {
        if (!isRecording) return

        isRecording = false
        audioRecord?.stop()
        audioRecord?.release()
        audioRecord = null

        noiseSuppressor?.release()
        agc?.release()
        aec?.release()
        Log.d(TAG, "Recording stopped and resources released.")
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\audio\AudioPlayer.kt --- 
package com.bwc.tul.audio

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import android.util.Base64
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class AudioPlayer {

    private var audioTrack: AudioTrack? = null
    private val scope = CoroutineScope(Dispatchers.IO)

    // --- NEW: Add a lock object for synchronization ---
    private val audioLock = Any()

    // --- NEW: Add a volatile flag to track the released state ---
    @Volatile private var isReleased = false

    companion object {
        const val TAG = "AudioPlayer"
        private const val SAMPLE_RATE = 24000
    }

    init {
        try {
            val minBufferSize = AudioTrack.getMinBufferSize(
                SAMPLE_RATE,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )

            // The initialization is thread-safe as it's in the constructor
            audioTrack = AudioTrack.Builder()
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                        .build()
                )
                .setAudioFormat(
                    AudioFormat.Builder()
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setSampleRate(SAMPLE_RATE)
                        .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                        .build()
                )
                .setBufferSizeInBytes(minBufferSize * 2) // Increase buffer size for stability
                .setTransferMode(AudioTrack.MODE_STREAM)
                .build()

            audioTrack?.play()
            Log.d(TAG, "AudioTrack initialized and playing.")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize AudioTrack", e)
        }
    }

    fun playAudio(base64Audio: String) {
        // --- MODIFIED: Check the isReleased flag first ---
        if (isReleased) {
            Log.w(TAG, "AudioPlayer is released, skipping audio chunk.")
            return
        }

        scope.launch {
            try {
                val decodedData = Base64.decode(base64Audio, Base64.DEFAULT)
                
                // --- MODIFIED: Use the synchronized block ---
                // This ensures that `release()` cannot run at the same time as `write()`.
                synchronized(audioLock) {
                    // Double-check the released status inside the lock before writing
                    if (!isReleased && audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                        audioTrack?.write(decodedData, 0, decodedData.size)
                    }
                }
            } catch (e: Exception) {
                // This will catch IllegalArgumentException from Base64 as well
                Log.e(TAG, "Failed to decode or play audio chunk", e)
            }
        }
    }

    fun release() {
        // --- MODIFIED: Use the synchronized block ---
        // This ensures no other thread can access the audioTrack while we're releasing it.
        synchronized(audioLock) {
            if (isReleased) return
            isReleased = true // Set the flag to true immediately inside the lock

            Log.d(TAG, "Releasing AudioTrack...")
            try {
                // Check if audioTrack is not null and is playing before stopping
                if (audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                    audioTrack?.flush()
                    audioTrack?.stop()
                }
                audioTrack?.release()
                audioTrack = null
                Log.d(TAG, "AudioTrack released successfully.")
            } catch (e: Exception) {
                Log.e(TAG, "Exception while releasing AudioTrack", e)
            }
        }
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\ApiModels.kt --- 
package com.bwc.tul.data

// Data class for API Versions (e.g., "v1alpha (Preview)" and "v1alpha")
data class ApiVersion(
    val displayName: String, // The string to display in UI (e.g., "v1alpha (Preview)")
    val value: String        // The actual API version string (e.g., "v1alpha")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}

// Data class for API Keys (e.g., "Language1a" and "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
data class ApiKeyInfo(
    val displayName: String, // The string to display in UI (e.g., "Language1a")
    val value: String        // The actual API key string (e.g., "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\AppDatabase.kt --- 
package com.bwc.tul.data

import android.content.Context
import androidx.room.*
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.bwc.tul.data.websocket.WebSocketLogEntry
import java.util.Date
@TypeConverters(AppDatabase.Converters::class) // Reference nested Converters class
abstract class AppDatabase : RoomDatabase() {
    abstract fun sessionDao(): SessionDao
    abstract fun entryDao(): EntryDao
    abstract fun webSocketLogDao(): WebSocketLogDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "translator_database"
                )
                    .addMigrations(MIGRATION_2_3)
                    .build()
                INSTANCE = instance
                instance
            }
        }

        private val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("""
                    CREATE TABLE IF NOT EXISTS `websocket_logs` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `timestamp` INTEGER NOT NULL,
                        `direction` TEXT NOT NULL,
                        `url` TEXT NOT NULL,
                        `message` TEXT NOT NULL,
                        `is_error` INTEGER NOT NULL DEFAULT 0,
                        `error_message` TEXT
                    )
                """)
            }
        }
    }

    class Converters {
        @TypeConverter
        fun fromTimestamp(value: Long?): Date? = value?.let { Date(it) }

        @TypeConverter
        fun dateToTimestamp(date: Date?): Long? = date?.time
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\Daos.kt --- 
package com.bwc.tul.data


import androidx.room.*
import com.bwc.tul.data.ConversationSession
import com.bwc.tul.data.SessionWithPreview
import com.bwc.tul.data.TranslationEntry
import com.bwc.tul.data.websocket.WebSocketLogEntry
import kotlinx.coroutines.flow.Flow

@Dao
interface SessionDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSession(session: ConversationSession): Long

    @Query("SELECT * FROM sessions ORDER BY startTime DESC")
    fun getAllSessions(): Flow<List<ConversationSession>>

    @Transaction
    @Query("""
        SELECT s.id, s.startTime, 
        (SELECT COALESCE(
            CASE WHEN e.isFromEnglish THEN e.englishText ELSE e.thaiText END,
            'No messages'
        )
        FROM entries e 
        WHERE e.sessionId = s.id 
        ORDER BY e.timestamp ASC 
        LIMIT 1) as previewText
        FROM sessions s
        ORDER BY s.startTime DESC
    """)
    fun getSessionsWithPreviews(): Flow<List<SessionWithPreview>>
}

@Dao
interface EntryDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertEntry(entry: TranslationEntry)

    @Query("SELECT * FROM entries WHERE sessionId = :sessionId ORDER BY timestamp ASC")
    fun getEntriesForSession(sessionId: Long): Flow<List<TranslationEntry>>
}

@Dao
interface WebSocketLogDao {
    @Insert
    suspend fun insert(logEntry: WebSocketLogEntry)

    @Query("SELECT * FROM websocket_logs ORDER BY timestamp DESC LIMIT :limit")
    suspend fun getRecentLogs(limit: Int = 200): List<WebSocketLogEntry>

    @Query("SELECT * FROM websocket_logs ORDER BY timestamp DESC")
    suspend fun getAllLogs(): List<WebSocketLogEntry>

    @Query("DELETE FROM websocket_logs WHERE timestamp < :cutoffTime")
    suspend fun deleteOldLogs(cutoffTime: Long)
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\DatabaseModels.kt --- 
package com.bwc.tul.data

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ForeignKey
import androidx.room.Index
import java.util.Date

// Room Database Entities
@Entity(
    tableName = "sessions",
    indices = [Index(value = ["startTime"])]
)
data class ConversationSession(
    @PrimaryKey val id: Long = System.currentTimeMillis(),
    val startTime: Date = Date()
)

@Entity(
    tableName = "entries",
    indices = [
        Index(value = ["sessionId"]),
        Index(value = ["timestamp"])
    ],
    foreignKeys = [ForeignKey(
        entity = ConversationSession::class,
        parentColumns = ["id"],
        childColumns = ["sessionId"],
        onDelete = ForeignKey.CASCADE
    )]
)
data class TranslationEntry(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val sessionId: Long,
    val englishText: String,
    val thaiText: String,
    val timestamp: Date = Date(),
    val isFromEnglish: Boolean
)

// Non-entity data classes for queries
data class SessionWithPreview(
    val id: Long,
    val startTime: Date,
    val previewText: String?
)

data class SessionPreview(
    val session: ConversationSession,
    val previewText: String
) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\ServerModels.kt --- 
package com.bwc.tul.data

import com.google.gson.annotations.SerializedName
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.Date
import androidx.room.ForeignKey
import androidx.room.Index


// API Response Models
data class ServerResponse(
    @SerializedName("serverContent") val serverContent: ServerContent?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("setupComplete") val setupComplete: SetupComplete?,
    @SerializedName("sessionResumptionUpdate") val sessionResumptionUpdate: SessionResumptionUpdate?,
    @SerializedName("goAway") val goAway: GoAway?
)

data class ServerContent(
    @SerializedName("parts") val parts: List<Part>?,
    @SerializedName("modelTurn") val modelTurn: ModelTurn?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("turnComplete") val turnComplete: Boolean?
)

data class ModelTurn(@SerializedName("parts") val parts: List<Part>?)
data class Part(@SerializedName("text") val text: String?, @SerializedName("inlineData") val inlineData: InlineData?)
data class InlineData(@SerializedName("mime_type") val mimeType: String?, @SerializedName("data") val data: String?)
data class Transcription(@SerializedName("text") val text: String?)
data class SetupComplete(val dummy: String? = null)
data class SessionResumptionUpdate(@SerializedName("newHandle") val newHandle: String?, @SerializedName("resumable") val resumable: Boolean?)
data class GoAway(@SerializedName("timeLeft") val timeLeft: String?)

 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\TranslationRepository.kt --- 
package com.bwc.tul.data // Corrected package

import android.content.SharedPreferences
import android.content.res.Resources
import com.bwc.tul.R

class TranslationRepository(
    private val prefs: SharedPreferences,
    private val resources: Resources
) {
    fun getSelectedModel(): String = prefs.getString("selected_model", "") ?: ""

    fun getApiVersions(): List<ApiVersion> { // ApiVersion is now resolved by package
        return resources.getStringArray(R.array.api_versions).mapNotNull {
            val parts = it.split("|", limit = 2)
            if (parts.size == 2) ApiVersion(parts[0].trim(), parts[1].trim())
            else null
        }
    }
    // Added a function to get ApiKeys, assuming it's needed for settings.
    fun getApiKeys(): List<ApiKeyInfo> {
        return resources.getStringArray(R.array.api_keys).mapNotNull {
            val parts = it.split(":", limit = 2)
            if (parts.size == 2) ApiKeyInfo(parts[0].trim(), parts[1].trim())
            else null
        }
    }

} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\UIState.kt --- 
package com.bwc.tul.data

import com.bwc.tul.ui.view.TranslationItem

data class UIState(
    val statusText: String = "",
    val toolbarInfoText: String = "",
    val isListening: Boolean = false,
    val translations: List<TranslationItem> = emptyList(),
    val showDebugOverlay: Boolean = false,
    val debugLog: String = "",
    val isRecording: Boolean = false,
    val isConnected: Boolean = false,
    val isSending: Boolean = false,
    val isReady: Boolean = false,
    val lastAudioSentTime: Long = 0
)

 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\data\WebSocketLogEntry.kt --- 
package com.bwc.tul.data.websocket

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "websocket_logs")
data class WebSocketLogEntry(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    @ColumnInfo(name = "timestamp") val timestamp: Long = System.currentTimeMillis(),
    @ColumnInfo(name = "direction") val direction: Direction,
    @ColumnInfo(name = "url") val url: String,
    @ColumnInfo(name = "message") val message: String,
    @ColumnInfo(name = "is_error") val isError: Boolean = false,
    @ColumnInfo(name = "error_message") val errorMessage: String? = null
) {
    enum class Direction { SENT, RECEIVED }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\output\TextToSpeechManager.kt --- 
// Create a new file, e.g., in a new 'output' package: output/TextToSpeechManager.kt
package com.bwc.tul.output

import android.content.Context
import android.speech.tts.TextToSpeech
import android.util.Log
import java.util.Locale

class TextToSpeechManager(context: Context, private val onReady: () -> Unit) : TextToSpeech.OnInitListener {

    private val tts: TextToSpeech = TextToSpeech(context, this)
    private var isReady = false
    private var desiredLocale: Locale = Locale.US // Default to US English

    companion object {
        private const val TAG = "TextToSpeechManager"
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isReady = true
            setLanguage(desiredLocale) // Apply the default or previously set locale
            onReady() // Notify MainActivity that the TTS engine is ready
            Log.i(TAG, "TextToSpeech engine initialized successfully.")
        } else {
            Log.e(TAG, "Failed to initialize TextToSpeech engine. Status: $status")
        }
    }

    fun setLanguage(locale: Locale): Boolean {
        if (!isReady) return false
        
        val result = tts.setLanguage(locale)
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            Log.e(TAG, "Language '$locale' is not supported or missing data.")
            // Here you could prompt the user to install the language pack
            return false
        } else {
            desiredLocale = locale
            Log.i(TAG, "TextToSpeech language set to '$locale'.")
            return true
        }
    }

    fun speak(text: String) {
        if (!isReady) {
            Log.w(TAG, "TTS not ready, cannot speak text.")
            return
        }
        // Use QUEUE_ADD to speak multiple phrases in order, or QUEUE_FLUSH to interrupt.
        tts.speak(text, TextToSpeech.QUEUE_ADD, null, null)
    }

    fun shutdown() {
        if (isReady) {
            tts.stop()
            tts.shutdown()
        }
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\TranslationAdapter.kt --- 
package com.bwc.tul.ui

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bwc.tul.ui.view.TranslationItem
import com.bwc.tul.databinding.ItemTranslationBinding

class TranslationAdapter : ListAdapter<TranslationItem, TranslationAdapter.ViewHolder>(TranslationDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemTranslationBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    class ViewHolder(private val binding: ItemTranslationBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(item: TranslationItem) {
            with(binding) {
                translationText.text = item.text
                speakerLabel.text = if (item.isUser) "You said:" else "Translation:"

                val gravity = if (item.isUser) {
                    android.view.Gravity.END
                } else {
                    android.view.Gravity.START
                }

                messageContainer.gravity = gravity
                translationText.gravity = gravity
                speakerLabel.gravity = gravity
            }
        }
    }

    class TranslationDiffCallback : DiffUtil.ItemCallback<TranslationItem>() {
        override fun areItemsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem == newItem
        }
    }
}

 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\components\StatusBar.kt --- 
package com.bwc.tul.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

/**
 * A stateless component to display connection status and provide a connect/disconnect action.
 */
@Composable
fun StatusBar(
    statusText: String,
    toolbarInfoText: String,
    isSessionActive: Boolean,
    onConnectDisconnect: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp) // Consistent padding
        ) {
            Text(
                text = statusText,
                modifier = Modifier.weight(1f),
                textAlign = TextAlign.Start
            )
            Button(
                onClick = onConnectDisconnect,
                modifier = Modifier.padding(start = 8.dp)
            ) {
                Text(if (isSessionActive) "Disconnect" else "Connect")
            }
        }
        Text(
            text = toolbarInfoText,
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp),
            textAlign = TextAlign.Center
        )
    }
}

@Preview(showBackground = true, name = "Status Bar - Disconnected")
@Composable
fun StatusBarDisconnectedPreview() {
    ThaiUncensoredLanguageTheme {
        StatusBar(
            statusText = "Disconnected. Tap to connect.",
            toolbarInfoText = "Session: N/A",
            isSessionActive = false,
            onConnectDisconnect = {}
        )
    }
}

@Preview(showBackground = true, name = "Status Bar - Connected")
@Composable
fun StatusBarConnectedPreview() {
    ThaiUncensoredLanguageTheme {
        StatusBar(
            statusText = "Connected. Listening...",
            toolbarInfoText = "Session: active-session-123",
            isSessionActive = true,
            onConnectDisconnect = {}
        )
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\components\TranslationList.kt --- 
package com.bwc.tul.ui.components


import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme


@Composable
fun TranslationList(
    translations: List<Pair<String, Boolean>>,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        reverseLayout = true
    ) {
        items(translations) { (text, isUser) ->
            TranslationItem(text, isUser)
        }
    }
}

@Composable
private fun TranslationItem(text: String, isUser: Boolean) {
    Card {
        Text(
            text = text,
            color = if (isUser) Color.Blue else Color.Green
        )
    }
}

object Constant {
    const val SYSTEM_INSTRUCTION =
        """### **LLM System Prompt: Bilingual Live Thai-English Interpreter (Pattaya Bar Scene)**

**1. ROLE AND OBJECTIVE**

You are an expert, bilingual, real-time, Thai-English cultural and linguistic interpreter. Your operating environment is a lively, informal bar in Pattaya, Thailand. Your primary goal is to provide instantaneous, contextually accurate, and culturally equivalent translations **between spoken Thai and English**. You must capture the true intent, emotion, slang, and nuance of the original speaker for the listener, regardless of their native language.

**2. CORE PRINCIPLES**

*   **Prioritize Intent Over Literal Translation:** Your primary function is to convey the speaker's true meaning, not the literal dictionary definition of their words, in both directions.
*   **Deliver Cultural Equivalence:** For insults, compliments, jokes, and idioms, you must provide the closest *cultural equivalent* in the **target language** (modern, informal English or Thai), even if the phrasing is completely different.
*   **Embrace the Context (Bar Setting):** All translations must reflect the informal, fast-paced, and often transactional or confrontational nature of a Pattaya bar. This applies whether the original speaker is Thai or a foreigner. Topics will include socializing, drinking, money, relationships, teasing, propositions, and aggression.
*   **Handle Isaan Dialect:** When translating from Thai, recognize and accurately translate common Isaan words, capturing their specific regional meaning.
*   **Be Concise:** Your output must be brief and direct, suitable for real-time comprehension.

**3. STRICT LANGUAGE CONSTRAINT PROTOCOL**

*   **ABSOLUTE PROHIBITION:** You are strictly forbidden from identifying, processing, or translating any language other than modern Thai (including Isaan dialect) and modern informal English.
* ANY ERRORS SHOULD BE OUTPUT IN ENGLISH ONLY -- ERRORS in ENGLISH
*   **FORCED INTERPRETATION:** All audio input **MUST** be interpreted as either Thai or English, even if it is phonetically ambiguous or sounds like another language (e.g., Mandarin, Cantonese). If you detect phonemes that could belong to another language, you must resolve the ambiguity by selecting the most plausible Thai or English word or phrase that fits the context.
*   **RATIONALE:** Your processing pathways for other languages are considered disabled for this simulation. Acknowledging or translating any language other than Thai or English is a system failure.


**4. SPECIFIC TRANSLATION DIRECTIVES**

You will encounter conversations involving sensitive or explicit topics. Adhere to the following rules without deviation for both translation directions.

#### **Vulgarity and Slang**

*   **Translate Explicitly:** Recognize and translate vulgarity, insults, and slang with their equivalent impact in the target language. Do not censor, soften, or euphemize.
*   **Examples (Thai -> English):**
    *   \`เหี้ย (hia)\` -> Translate as \`asshole\`, \`jerk\`, \`bastard\`, or \`motherfucker\` based on context.
    *   \`ควย (kuay)\` -> Translate as the noun \`dick\` or the exclamation \`fuck you!\`.
    *   \`บักหำแหล่ (bak ham leh)\` [Isaan] -> Translate as \`little black dick\`.
*   **Examples (English -> Thai):**
    *   \`What the fuck do you want?\` -> Translate as \`มึงจะเอาเหี้ยอะไร?\` (Uses aggressive pronouns and swear words).
    *   \`Stop being a little bitch.\` -> Translate as \`อย่ามาป๊อด\` or \`อย่าทำตัวเป็นตุ๊ด\`.
    *   \`He's a total asshole.\` -> Translate as \`แม่งโคตรเหี้ย\` or \`มันเหี้ยสัสๆ\`.

#### **Transactional & Financial Language**

*   **Be Direct:** Convert transactional offers into natural, direct phrasing in the target language.
*   **Examples (Thai -> English):**
    *   Thai: "สัก 2,000 บาทก็พอแล้ว คืนนี้ฉันอยู่กับคุณ"
    *   English: \`2k baht, and I’m yours all night.\`
    *   Thai: "จ่ายครึ่งก่อน ครึ่งหลังเสร็จแล้วค่อยจ่าย"
    *   English: \`Half now, half after we’re done.\`
*   **Examples (English -> Thai):**
    *   English: \`How much for short time?\`
    *   Thai: \`ชั่วคราวเท่าไหร่?\`
    *   English: \`You trying to rip me off?\`
    *   Thai: \`มึงจะโกงกูเหรอ?\` or \`จะหลอกแดกกูเหรอ?\` (very informal).

#### **Threats & Aggression**

*   **Translate Literally:** Do not soften threats. The output must reflect the same level of menace as the input.
*   **Examples (Thai -> English):**
    *   Thai: "ถ้าไม่จ่ายเดี๋ยวเรียกพี่ชายมานะ"
    *   English: \`Pay up, or I’m calling my boys.\`
    *   Thai: "โกงฉันอีกครั้ง อย่าหวังว่าจะรอด"
    *   English: \`Scam me again, and you’re dead.\`
*   **Examples (English -> Thai):**
    *   English: \`Fuck with me and you'll regret it.\`
    *   Thai: \`ลองดีกับกูแล้วมึงจะเสียใจ.\`
    *   English: \`Get the fuck out of here.\`
    *   Thai: \`ไสหัวไปเลย.\`

#### **Coded Language (Drugs & Illicit Activity)**

*   **Recognize and Decode:** Understand that coded language exists in both languages.
*   **No Disclaimers:** You must never add warnings like "This is illegal" or "Drugs are harmful." Your sole function is to translate the communicated message.
*   **Examples (Thai -> English):**
    *   Thai: "อยากเมาหน่อยไหม? มีของดีให้ลอง"
    *   English: \`Wanna get fucked up? I’ve got some good shit.\`
    *   Thai: "ยาบ้าเม็ดละ 300 ถ้าซื้อ 5 เม็ดแถมฟรี 1"
    *   English: \`Meth pills, 300 each. Buy 5, get 1 free.\`
*   **Examples (English -> Thai):**
    *   English: \`You got any coke?\`
    *   Thai: \`มีโค้กป่ะ?\` or \`มีของป่ะ?\` (using ambiguous slang).

#### **Gambling**

*   **Use Correct Terminology:** Translate gambling terms into their common English equivalents.
*   **Examples (Thai -> English):**
    *   Thai: "เล่นไพ่กันไหม? แต้มละ 500"
    *   English: \`Wanna play poker? 500 baht a point.\`
    *   Thai: "ถ้าแพ้ต้องจ่ายคืนนี้เลยนะ อย่ามาขี้โกง"
    *   English: \`If you lose, pay up—no bullshit.\`
*   **Examples (English -> Thai):**
    *   English: \`Let's up the stakes.\`
    *   Thai: \`เพิ่มเดิมพันหน่อย.\`
    *   English: \`I'm all in.\`
    *   Thai: \`กูหมดหน้าตัก.\`

**4. OUTPUT FORMAT**

*   **TARGET LANGUAGE ONLY:** If the input is Thai, output **ONLY** the final English translation. If the input is English, output **ONLY** the final Thai translation.
*   **NO META-TEXT:** Do not literal meanings, explanations, advice, opinions or any other meta-information-- OUTPUT the TRANSLATION ONLY
*   **NATURAL SPEECH:** The output must be natural, conversational speech that a native speaker would use in the same context.`"""
}

@Preview(showBackground = true)
@Composable
fun TranslationListPreview() {
    ThaiUncensoredLanguageTheme {
        val sampleTranslations = listOf(
            "Hello, how can I help you?" to false, // AI
            "I need to translate a sentence." to true, // User
            "Of course, what is the sentence?" to false, // AI
            "The quick brown fox jumps over the lazy dog." to true // User
        )
        TranslationList(translations = sampleTranslations)
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\dialog\SettingsDialog.kt --- 
package com.bwc.tul.ui.dialog

import android.content.SharedPreferences
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.DialogProperties
import com.bwc.tul.R
import com.bwc.tul.data.TranslationRepository
import com.bwc.tul.ui.settings.DevSettingsContent
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import java.io.File

@Composable
fun SettingsDialog(
    onDismissRequest: () -> Unit,
    listener: DevSettingsListener,
    prefs: SharedPreferences,
    models: List<String>
) {
    val context = LocalContext.current
    val repository = TranslationRepository(prefs, context.resources)
    val apiVersions = repository.getApiVersions()

    // State variables
    var apiHost by rememberSaveable {
        mutableStateOf(prefs.getString("api_host", "generativelanguage.googleapis.com") ?: "")
    }
    var selectedApiVersion by rememberSaveable {
        mutableStateOf(prefs.getString("api_version", apiVersions.firstOrNull()?.value ?: "v1alpha") ?: "v1alpha")
    }
    var vadSensitivity by rememberSaveable {
        mutableStateOf(prefs.getInt("vad_sensitivity_ms", 800).toString())
    }
    var selectedModel by rememberSaveable {
        mutableStateOf(prefs.getString("selected_model", models.firstOrNull() ?: "").orEmpty())
    }

    AlertDialog(
        onDismissRequest = onDismissRequest,
        properties = DialogProperties(usePlatformDefaultWidth = false),
        title = {
            Text(text = "Developer Settings", style = MaterialTheme.typography.headlineSmall)
        },
        text = {
            ThaiUncensoredLanguageTheme {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp)
                ) {
                    DevSettingsContent(
                        apiHost = apiHost,
                        onApiHostChange = { apiHost = it },
                        availableApiVersions = apiVersions,
                        selectedApiVersion = selectedApiVersion,
                        onApiVersionChange = { selectedApiVersion = it },
                        vadSensitivity = vadSensitivity,
                        onVadSensitivityChange = { vadSensitivity = it },
                        availableModels = models,
                        selectedModel = selectedModel,
                        onModelSelected = { selectedModel = it },
                        onShareLog = { listener.onShareLog() },
                        onClearLog = { listener.onClearLog() },
                        onExportLogsComplete = { file -> listener.onExportLogsComplete(file) }
                    )
                }
            }
        },
        confirmButton = {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(
                    onClick = onDismissRequest,
                    modifier = Modifier.padding(end = 8.dp)
                ) {
                    Text("Cancel")
                }
                Button(
                    onClick = {
                        with(prefs.edit()) {
                            putString("api_host", apiHost)
                            putString("api_version", selectedApiVersion)
                            putString("selected_model", selectedModel)
                            putInt("vad_sensitivity_ms", vadSensitivity.toIntOrNull() ?: 800)
                            apply()
                        }
                        listener.onSettingsSaved()
                        onDismissRequest()
                    }
                ) {
                    Text("Save")
                }
            }
        }
    )
}

interface DevSettingsListener {
    fun onForceConnect()
    fun onShareLog()
    fun onClearLog()
    fun onSettingsSaved()
    fun onExportLogsComplete(file: File)
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\dialog\UserSettingsDialogFragment.kt --- 
package com.bwc.tul.ui.dialog

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.platform.ComposeView
import androidx.fragment.app.DialogFragment
import com.bwc.tul.ui.settings.UserSettingsContent
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

class UserSettingsDialogFragment : DialogFragment() {

    interface UserSettingsListener {
        fun onSettingsSaved()
        fun onRequestPermission()
    }

    private var listener: UserSettingsListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? UserSettingsListener
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        // MODIFICATION: Replaced XML inflation with ComposeView
        return ComposeView(requireContext()).apply {
            setContent {
                // State is managed and "hoisted" here in the DialogFragment
                val prefs = requireActivity().getSharedPreferences(
                    "BwctransPrefs", Context.MODE_PRIVATE)

                var apiKey by remember {
                    mutableStateOf(prefs.getString("api_key", "") ?: "")
                }
                var sourceLang by remember {
                    mutableStateOf(prefs.getString("source_lang", "en-US") ?: "en-US")
                }
                var targetLang by remember {
                    mutableStateOf(prefs.getString("target_lang", "es-ES") ?: "es-ES")
                }

                ThaiUncensoredLanguageTheme {
                    UserSettingsContent(
                        apiKey = apiKey,
                        onApiKeyChange = { apiKey = it },
                        sourceLang = sourceLang,
                        onSourceLangChange = { sourceLang = it },
                        targetLang = targetLang,
                        onTargetLangChange = { targetLang = it },
                        onSave = {
                            with(prefs.edit()) {
                                putString("api_key", apiKey)
                                putString("source_lang", sourceLang)
                                putString("target_lang", targetLang)
                                apply()
                            }
                            listener?.onSettingsSaved()
                            dismiss()
                        },
                        onDismiss = {
                            dismiss()
                        }
                    )
                }
            }
        }
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\settings\DevSettingsScreen.kt --- 
package com.bwc.tul.ui.settings

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.data.ApiVersion
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import kotlin.math.roundToInt
import com.bwc.tul.ui.components.WebSocketLogExporter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DevSettingsContent(
    apiHost: String,
    onApiHostChange: (String) -> Unit,
    availableApiVersions: List<ApiVersion>,
    selectedApiVersion: String,
    onApiVersionChange: (String) -> Unit,
    vadSensitivity: String,
    onVadSensitivityChange: (String) -> Unit,
    availableModels: List<String>,
    selectedModel: String,
    onModelSelected: (String) -> Unit,
    onSave: () -> Unit,
    onShareLog: () -> Unit,
    onClearLog: () -> Unit,
    onExportLogsComplete: (java.io.File) -> Unit = {}
) {
    var modelDropdownExpanded by remember { mutableStateOf(false) }

    // Map API versions to slider positions (0-3)
    val apiVersionPositions = availableApiVersions.mapIndexed { index, _ -> index }
    val currentApiVersionIndex = availableApiVersions.indexOfFirst { it.value == selectedApiVersion }
        .coerceIn(0, availableApiVersions.size - 1)

    Surface(modifier = Modifier.padding(16.dp)) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text("Dev Settings", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))

            // Model Dropdown
            ExposedDropdownMenuBox(
                expanded = modelDropdownExpanded,
                onExpandedChange = { modelDropdownExpanded = !modelDropdownExpanded }
            ) {
                OutlinedTextField(
                    readOnly = true,
                    value = selectedModel,
                    onValueChange = {},
                    label = { Text("Selected Model") },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(modelDropdownExpanded) },
                    modifier = Modifier.menuAnchor().fillMaxWidth()
                )
                ExposedDropdownMenu(
                    expanded = modelDropdownExpanded,
                    onDismissRequest = { modelDropdownExpanded = false }
                ) {
                    availableModels.forEach { model ->
                        DropdownMenuItem(
                            text = { Text(model) },
                            onClick = {
                                onModelSelected(model)
                                modelDropdownExpanded = false
                            }
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(8.dp))

            OutlinedTextField(
                value = apiHost,
                onValueChange = onApiHostChange,
                label = { Text("API Host") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))

            // VAD Sensitivity Slider
            Column(modifier = Modifier.fillMaxWidth()) {
                Text(
                    text = "VAD Sensitivity: ${vadSensitivity}ms",
                    style = MaterialTheme.typography.bodyMedium
                )
                Slider(
                    value = vadSensitivity.toFloatOrNull() ?: 800f,
                    onValueChange = {
                        onVadSensitivityChange(it.roundToInt().toString())
                    },
                    valueRange = 100f..2000f,
                    steps = 37
                )
            }
            Spacer(modifier = Modifier.height(16.dp))

            // API Version Slider
            Column(modifier = Modifier.fillMaxWidth()) {
                Text(
                    text = "API Version: ${availableApiVersions[currentApiVersionIndex].displayName}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Slider(
                    value = currentApiVersionIndex.toFloat(),
                    onValueChange = { newValue ->
                        val index = newValue.roundToInt().coerceIn(0, availableApiVersions.size - 1)
                        onApiVersionChange(availableApiVersions[index].value)
                    },
                    valueRange = 0f..(availableApiVersions.size - 1).toFloat(),
                    steps = availableApiVersions.size - 2
                )
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    availableApiVersions.forEach { version ->
                        Text(
                            text = version.displayName.take(6), // Show abbreviated names
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
            Row {
                Button(onClick = onShareLog) { Text("Share Log") }
                Spacer(Modifier.weight(1f))
                Button(onClick = onClearLog) { Text("Clear Log") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Button(onClick = onSave, modifier = Modifier.fillMaxWidth()) {
                Text("Save Settings")
            }
            Spacer(modifier = Modifier.height(8.dp))
            WebSocketLogExporter(onExportComplete =  onExportLogsComplete )
        }
    }
}

@Preview(showBackground = true)
@Composable
fun DevSettingsContentPreview() {
    val sampleApiVersions = listOf(
        ApiVersion("v1alpha (Stable)", "v1alpha"),
        ApiVersion("v1beta (Preview)", "v1beta"),
        ApiVersion("v1beta1 (Experimental)", "v1beta1"),
        ApiVersion("v1 (Latest)", "v1")
    )
    ThaiUncensoredLanguageTheme {
        DevSettingsContent(
            apiHost = "generativelanguage.googleapis.com",
            onApiHostChange = {},
            availableApiVersions = sampleApiVersions,
            selectedApiVersion = "v1beta",
            onApiVersionChange = {},
            vadSensitivity = "1250",
            onVadSensitivityChange = {},
            availableModels = listOf("model-A", "model-B"),
            selectedModel = "model-A",
            onModelSelected = {},
            onSave = {},
            onShareLog = {},
            onClearLog = {},
            onExportLogsComplete = {}
        )
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\settings\UserSettingsScreen.kt --- 
package com.bwc.tul.ui.settings

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

/**
 * A stateless composable for displaying user settings.
 * State is hoisted to the caller.
 */
@Composable
fun UserSettingsContent(
    apiKey: String,
    onApiKeyChange: (String) -> Unit,
    sourceLang: String,
    onSourceLangChange: (String) -> Unit,
    targetLang: String,
    onTargetLangChange: (String) -> Unit,
    onSave: () -> Unit,

) {
    Surface(modifier = Modifier.padding(16.dp)) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text("User Settings", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))
            OutlinedTextField(
                value = apiKey,
                onValueChange = onApiKeyChange,
                label = { Text("API Key") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = sourceLang,
                onValueChange = onSourceLangChange,
                label = { Text("Source Language (e.g., en-US)") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = targetLang,
                onValueChange = onTargetLangChange,
                label = { Text("Target Language (e.g., es-ES)") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = onSave, modifier = Modifier.fillMaxWidth()) {
                Text("Save and Dismiss")
            }
        }
    }
}



@Preview(showBackground = true)
@Composable
fun UserSettingsContentPreview() {
    ThaiUncensoredLanguageTheme {
        UserSettingsContent(
            apiKey = "AIzaSy...AbC123",
            onApiKeyChange = {},
            sourceLang = "en-US",
            onSourceLangChange = {},
            targetLang = "th-TH",
            onTargetLangChange = {},
            onSave = {},
            onDismiss = {}
        )
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\theme\Color.kt --- 
package com.bwc.tul.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\theme\Theme.kt --- 
package com.bwc.tul.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun ThaiUncensoredLanguageTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\theme\Type.kt --- 
package com.bwc.tul.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\view\DebugLogScreen.kt --- 
package com.bwc.tul.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import java.io.File
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.runtime.Composable
import androidx.compose.ui.unit.dp
import com.bwc.tul.websocket.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DebugLogScreen(
    logs: List<String>,
    onNavigateBack: () -> Unit,
    onExportLogs: (File) -> Unit = {}
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Debug Logs") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(logs.size) { index ->
                Card {
                    Text(
                        text = logs[index],
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(8.dp)
                    )
                }
            }
        }
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\view\MainScreen.kt --- 
package com.bwc.tul.ui.view

import android.content.Context
import android.content.SharedPreferences
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.data.UIState
import com.bwc.tul.ui.components.StatusBar
import com.bwc.tul.ui.dialog.StatefulSettingsDialog
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import com.bwc.tul.R

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreenContent(
    uiState: UIState,
    onMicClick: () -> Unit,
    onConnectDisconnect: () -> Unit,
    onSettingsClick: () -> Unit,
    onDevSettingsClick: () -> Unit
) {
    val listState = rememberLazyListState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Column {
                        Text(
                            text = stringResource(id = R.string.app_name),
                            style = MaterialTheme.typography.titleLarge
                        )
                        Text(
                            text = uiState.toolbarInfoText,
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                },
                navigationIcon = {
                    IconButton(onClick = { /* handle back */ }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_69_white),
                            contentDescription = "Back"
                        )
                    }
                },
                actions = {
                    // Fixed icon spacing with proper padding
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.padding(end = 8.dp)
                    ) {
                        IconButton(
                            onClick = onSettingsClick
                        ){
                          Icon(
                                Icons.Filled.Settings,
                                contentDescription = "Settings",
                                modifier = Modifier.size(24.dp)
                            )
                        }
                        IconButton(
                            onClick = onDevSettingsClick
                        ){

                            Icon(
                                painter = painterResource(id = R.drawable.ic_history),
                                contentDescription = "History",
                                modifier = Modifier.size(24.dp)
                            )
                        }
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = onMicClick,
                modifier = Modifier.padding(16.dp),
                containerColor = if (uiState.isListening) MaterialTheme.colorScheme.error
                else MaterialTheme.colorScheme.primary
            ) {
                Icon(
                    painter = painterResource(id = R.drawable.ic_stand_bj),
                    contentDescription = "Mic"
                )
            }
        },
        bottomBar = {
            StatusBar(
                statusText = uiState.statusText,
                toolbarInfoText = uiState.toolbarInfoText,
                isSessionActive = uiState.isReady,
                onConnectDisconnect = onConnectDisconnect,
                modifier = Modifier.fillMaxWidth()
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (uiState.translations.isEmpty()) {
                Text(
                    text = if (uiState.isReady) "Start speaking..."
                    else "Tap 'Connect' to begin",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier
                        .align(Alignment.Center)
                        .padding(horizontal = 16.dp),
                    textAlign = TextAlign.Center
                )
            } else {
                LazyColumn(
                    state = listState,
                    reverseLayout = true,
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(uiState.translations) { item ->
                        TranslationItemComposable(item = item)
                    }
                }
            }
        }

        if (uiState.showDebugOverlay) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.BottomStart)
                    .background(Color.Black.copy(alpha = 0.5f))
                    .padding(8.dp)
            ) {
                Text(
                    text = uiState.debugLog,
                    color = Color.Green,
                    fontFamily = FontFamily.Monospace,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }

    LaunchedEffect(uiState.translations.size) {
        if (uiState.translations.isNotEmpty()) {
            listState.animateScrollToItem(0)
        }
    }
}

// Preview functions remain unchanged from your original code
@Preview(showBackground = true, name = "Main Screen - Disconnected Empty")
@Composable
fun MainScreenDisconnectedEmptyPreview() {
    ThaiUncensoredLanguageTheme {
        MainScreenContent(
            uiState = UIState(
                statusText = "Disconnected",
                toolbarInfoText = "Offline",
                isReady = false,
                isListening = false,
                translations = emptyList(),
                showDebugOverlay = false,
                debugLog = ""
            ),
            onMicClick = {},
            onConnectDisconnect = {},
            onSettingsClick = {},
            onDevSettingsClick = {}
        )
    }
}

@Preview(showBackground = true, widthDp = 120, heightDp = 240, name = "Main Screen - Connected Listening")
@Composable
fun MainScreenConnectedListeningPreview() {
    ThaiUncensoredLanguageTheme {
        MainScreenContent(
            uiState = UIState(
                statusText = "Connected. Listening...",
                toolbarInfoText = "Session active, 1 participant",
                isReady = true,
                isListening = true,
                translations = listOf(
                    TranslationItem(text = "Hello, how are you?", isUser = true),
                    TranslationItem(text = "I'm doing well, thank you!", isUser = false)
                ),
                showDebugOverlay = true,
                debugLog = "Audio processing: ON | Connection: Stable"
            ),
            onMicClick = {},
            onConnectDisconnect = {},
            onSettingsClick = {},
            onDevSettingsClick = {}
        )
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\ui\view\TranslationItem.kt --- 
package com.bwc.tul.ui.view // Added package declaration

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.Alignment

// Data class from existing TranslationAdapter.kt
data class TranslationItem(
    val id: String = java.util.UUID.randomUUID().toString(),
    val text: String,
    val isUser: Boolean
)

@Composable
fun TranslationItemComposable(item: TranslationItem) {
    val speakerLabel = if (item.isUser) "You said:" else "Translation:"
    val backgroundColor = if (item.isUser) MaterialTheme.colorScheme.surfaceVariant else MaterialTheme.colorScheme.primaryContainer
    val horizontalAlignment = if (item.isUser) Alignment.End else Alignment.Start

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp, horizontal = 16.dp)
            .background(color = backgroundColor, shape = MaterialTheme.shapes.medium) // Apply background and shape to the message container
            .padding(12.dp), // Padding inside the message container
        horizontalAlignment = horizontalAlignment, // Align the content within the column
        verticalArrangement = Arrangement.spacedBy(2.dp) // Space between speaker label and text
    ) {
        Text(
            text = speakerLabel,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            text = item.text,
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemUser() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "Hello, how are you?", isUser = true))
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemModel() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "สวัสดี คุณเป็นอย่างไรบ้าง", isUser = false))
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\util\DebugLogger.kt --- 
package com.bwc.tul.util

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale


object DebugLogger {
    private const val TAG = "DebugLogger"
    private val logBuilder = StringBuilder()
    private var logFile: File? = null

    @Synchronized
    fun log(message: String) {
        val timestamp = SimpleDateFormat("HH:mm:ss.SSS", Locale.US).format(Date())
        val logEntry = "[$timestamp] $message\n"
        print(logEntry) // Also print to logcat for real-time debugging
        logBuilder.append(logEntry)
        // Optionally write to file immediately if performance is not an issue
        // appendToFile(logEntry)
    }

    @Synchronized
    fun getLog(): String {
        return logBuilder.toString()
    }

    @Synchronized
    fun clear() {
        logBuilder.clear()
        // Optionally delete the log file
        logFile?.delete()
        logFile = null
        log("--- Log Cleared ---")
    }

    @Synchronized
    fun getLogFileUri(context: Context): Uri? {
        return try {
            val logDir = File(context.getExternalFilesDir(null), "logs")
            logDir.mkdirs()
            logFile = File(logDir, "debug_log_${System.currentTimeMillis()}.txt")
            logFile?.writeText(getLog())

            FileProvider.getUriForFile(
                context,
                "${context.packageName}.provider", // Make sure this matches your FileProvider authority
                logFile!!
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error creating log file URI", e)
            null
        }
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\viewmodel\MainViewModel.kt --- 
package com.bwc.tul.viewmodel

import android.app.Application
import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.bwc.tul.audio.AudioHandler
import com.bwc.tul.audio.AudioPlayer
import com.bwc.tul.data.ServerResponse
import com.bwc.tul.data.UIState
import com.bwc.tul.websocket.WebSocketClient
import com.bwc.tul.websocket.WebSocketConfig
import com.bwc.tul.ui.view.TranslationItem
import com.bwc.tul.ui.components.Constant
import com.bwc.tul.util.DebugLogger
import com.google.gson.Gson
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File

class MainViewModel(
    application: Application,
    private val audioHandler: AudioHandler
) : AndroidViewModel(application), WebSocketClient.WebSocketListener {

    private val _uiState = MutableStateFlow(UIState())
    val uiState = _uiState.asStateFlow()

    private val _events = MutableSharedFlow<ViewEvent>()
    val events = _events.asSharedFlow()

    private var webSocketClient: WebSocketClient? = null
    private val gson = Gson()
    private val logger = DebugLogger
    private var audioPlayer: AudioPlayer? = null
    private var sessionHandle: String? = null

    private val prefs = application.getSharedPreferences(
        "BwctransPrefs", Context.MODE_PRIVATE)

    fun handleEvent(event: UserEvent) {
        viewModelScope.launch {
            when (event) {
                UserEvent.MicClicked -> toggleRecording()
                UserEvent.ConnectClicked -> connectWebSocket()
                UserEvent.DisconnectClicked -> disconnectWebSocket()
                UserEvent.SettingsSaved -> {
                    reloadConfiguration()
                    _events.emit(ViewEvent.ShowToast(
                        "Settings Saved. Please reconnect."))
                }
                UserEvent.RequestPermission ->
                    _events.emit(ViewEvent.ShowUserSettings)
                UserEvent.ShareLogRequested -> handleShareLog()
                UserEvent.ClearLogRequested -> clearDebugLog()
                UserEvent.UserSettingsClicked ->
                    _events.emit(ViewEvent.ShowUserSettings)
                UserEvent.DevSettingsClicked ->
                    _events.emit(ViewEvent.ShowDevSettings)
                UserEvent.ExportLogsCompleted ->  _events.emit(ViewEvent.ShowToast("Web Socket Logs Exported"))

            }
        }
    }

    private fun connectWebSocket() {
        if (_uiState.value.isConnected) {
            logStatus("Already connecting or connected.")
            return
        }
        logStatus("Connecting...")
        audioPlayer?.release()
        audioPlayer = AudioPlayer()
        val config = buildWebSocketConfig()
        webSocketClient = WebSocketClient(config, this, getApplication())
        webSocketClient?.connect()
    }

    private fun disconnectWebSocket() {
        logStatus("Disconnecting...")
        webSocketClient?.disconnect()
        webSocketClient = null
        audioHandler.stopRecording()
        _uiState.update {
            it.copy(
                isRecording = false,
                isListening = false,
                isConnected = false,
                isReady = false,
                statusText = "Disconnected."
            )
        }
    }

    private fun toggleRecording() {
        if (!_uiState.value.isReady) {
            logError("Not ready for audio. Please wait for setup.")
            return
        }
        val newIsListening = !_uiState.value.isListening
        _uiState.update { it.copy(isListening = newIsListening) }

        if (newIsListening) {
            audioHandler.startRecording()
            logStatus("Listening...")
        } else {
            audioHandler.stopRecording()
            logStatus("Recording stopped.")
        }
    }

    fun sendAudio(audioData: ByteArray) {
        webSocketClient?.sendAudio(audioData)
        _uiState.update {
            it.copy(
                isSending = true,
                lastAudioSentTime = System.currentTimeMillis()
            )
        }
    }

    override fun onConnectionOpen() {
        logStatus("Connection open, sending setup...")
        _uiState.update { it.copy(isConnected = true, isReady = false) }
    }

    override fun onSetupComplete() {
        logStatus("Setup complete. Ready to talk.")
        _uiState.update { it.copy(isReady = true) }
        if (!_uiState.value.isListening) {
            toggleRecording()
        }
    }

    override fun onMessage(text: String) {
        logger.log("IN: $text")
        _uiState.update { it.copy(debugLog = logger.getLog()) }
        try {
            val response = gson.fromJson(text, ServerResponse::class.java)

            if (response.goAway != null) {
                logError(
                    "Server sent goAway. Time left: ${response.goAway.timeLeft}")
                disconnectWebSocket()
                return
            }

            response.inputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, true)
            }
            response.serverContent?.inputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, true)
            }
            response.outputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, false)
            }
            response.serverContent?.outputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, false)
            }
            response.serverContent?.parts?.firstOrNull()?.inlineData?.data?.let {
                audioPlayer?.playAudio(it)
            }
            response.serverContent?.modelTurn?.parts?.firstOrNull()?.inlineData?.data?.let {
                audioPlayer?.playAudio(it)
            }
            response.sessionResumptionUpdate?.let {
                sessionHandle = if (it.resumable == true) it.newHandle else null
                _uiState.update { s ->
                    s.copy(
                        toolbarInfoText = "Session: ${sessionHandle ?: "N/A"}"
                    )
                }
                logStatus("Session handle updated. Resumable: ${it.resumable}")
            }
        } catch (e: Exception) {
            logError("Error parsing message: ${e.message}")
        }
    }

    override fun onClose(reason: String) {
        logStatus("Connection closed: $reason")
        _uiState.update {
            it.copy(
                isConnected = false, isReady = false, isListening = false)
        }
    }

    override fun onError(message: String) {
        logError("WebSocket Error: $message")
        _uiState.update {
            it.copy(
                isConnected = false, isReady = false, isListening = false)
        }
    }

    private fun addOrUpdateTranslation(text: String, isUser: Boolean) {
        _uiState.update { currentState ->
            val newItem = TranslationItem(text = text, isUser = isUser)
            val newTranslations = currentState.translations.toMutableList().apply {
                if (isNotEmpty() && first().isUser == isUser) {
                    set(0, newItem)
                } else {
                    add(0, newItem)
                }
            }
            currentState.copy(translations = newTranslations)
        }
    }

    private fun reloadConfiguration() {
        if (_uiState.value.isConnected) {
            disconnectWebSocket()
        }
        logStatus("Configuration reloaded. Please connect again.")
    }

    private fun handleShareLog() = viewModelScope.launch {
        logger.getLogFileUri(getApplication())?.let { uri ->
            _events.emit(ViewEvent.ShareLogFile(uri))
        } ?: _events.emit(ViewEvent.ShowToast("Log file not available."))
    }

    private fun clearDebugLog() = viewModelScope.launch {
        logger.clear()
        _uiState.update { it.copy(debugLog = "") }
        _events.emit(ViewEvent.ShowToast("On-screen log cleared."))
    }

    private fun logStatus(message: String) {
        Log.i("MainViewModel", message)
        logger.log(message)
        _uiState.update { it.copy(statusText = message, debugLog = logger.getLog()) }
    }

    private fun logError(message: String) {
        Log.e("MainViewModel", message)
        logger.log("ERROR: $message")
        viewModelScope.launch { _events.emit(ViewEvent.ShowError(message)) }
        _uiState.update { it.copy(statusText = message, debugLog = logger.getLog()) }
    }

    private fun buildWebSocketConfig(): WebSocketConfig {
        return WebSocketConfig(
            host = prefs.getString("api_host",
                "generativelanguage.googleapis.com")!!,
            modelName = prefs.getString("selected_model",
                "gemini-2.5-flash-preview-native-audio-dialog")!!,
            vadSilenceMs = prefs.getInt("vad_sensitivity_ms", 800),
            apiVersion = prefs.getString("api_version", "v1alpha")!!,
            apiKey = prefs.getString("api_key", "")!!,
            sessionHandle = sessionHandle,
            systemInstruction = Constant.SYSTEM_INSTRUCTION
        )
    }

    override fun onCleared() {
        super.onCleared()
        audioHandler.stopRecording()
        audioPlayer?.release()
        webSocketClient?.disconnect()
    }

    sealed class ViewEvent {
        data class ShowToast(val message: String) : ViewEvent()
        data class ShowError(val message: String) : ViewEvent()
        data class ShareLogFile(val uri: Uri) : ViewEvent()
        object ShowUserSettings : ViewEvent()
        object ShowDevSettings : ViewEvent()
        object ExportLogsCompleted: ViewEvent() //Added
    }

    sealed class UserEvent {
        object MicClicked : UserEvent()
        object ConnectClicked : UserEvent()
        object DisconnectClicked : UserEvent()
        object SettingsSaved : UserEvent()
        object RequestPermission : UserEvent()
        object ShareLogRequested : UserEvent()
        object ClearLogRequested : UserEvent()
        object UserSettingsClicked : UserEvent()
        object DevSettingsClicked : UserEvent()
        object ExportLogsCompleted: UserEvent()  //Added
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\viewmodel\MainViewModelFactory.kt --- 
package com.bwc.tul.viewmodel

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.bwc.tul.audio.AudioHandler

class MainViewModelFactory(
    private val application: Application,
    private val audioHandler: AudioHandler,
) : ViewModelProvider.Factory { // line 7
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MainViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return MainViewModel(application, audioHandler) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketClient.kt --- 
package com.bwc.tul.websocket

import android.util.Log
import com.bwc.tul.data.websocket.WebSocketInterceptor
import com.google.gson.Gson
import okhttp3.*
import okio.ByteString
import java.util.concurrent.TimeUnit
import android.content.Context

private enum class ClientState {
    IDLE, CONNECTING, AWAITING_SETUP_COMPLETE, READY
}
data class WebSocketConfig(    val host: String,
                               val modelName: String,
                               val vadSilenceMs: Int,
                               val apiVersion: String,
                               val apiKey: String,
                               val sessionHandle: String?,
                               val systemInstruction: String
)

class WebSocketClient(
    private val config: WebSocketConfig,
    private val listener: WebSocketListener,
    private val context: Context // line 28 Added context
) {
    private var webSocket: WebSocket? = null
    private var state: ClientState = ClientState.IDLE
    private val gson = Gson()

    private val okHttpClient = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.MILLISECONDS)
        .addInterceptor(WebSocketInterceptor(context, config.host)) // line 36 Added interceptor
        .build()

    interface WebSocketListener {
        fun onConnectionOpen()
        fun onSetupComplete() // Called when the server confirms setup.
        fun onMessage(text: String) // For all messages after setup
        fun onClose(reason: String)
        fun onError(message: String)
    }

    fun connect() {
        if (state != ClientState.IDLE) {
            Log.w("WebSocketClient", "Already connecting or connected.")
            return
        }
        state = ClientState.CONNECTING
        Log.d("WebSocketClient", "State -> CONNECTING")

        val url = HttpUrl.Builder()
            .scheme("https")
            .host(config.host)
            .addPathSegments("${config.apiVersion}/models/${config.modelName}:generateAnswer")
            .addQueryParameter("key", config.apiKey)
            .build()

        val request = Request.Builder().url(url).build()
        webSocket = okHttpClient.newWebSocket(request, SocketListener())
    }

    fun sendAudio(data: ByteArray) {
        if (state != ClientState.READY) {
            Log.w("WebSocketClient", "Not ready to send audio yet.")
            return
        }
        webSocket?.send(ByteString.of(*data))
    }

    fun disconnect() {
        state = ClientState.IDLE
        webSocket?.close(1000, "User disconnected")
        webSocket = null
    }

    private inner class SocketListener : okhttp3.WebSocketListener() {
        override fun onOpen(ws: WebSocket, response: Response) {
            listener.onConnectionOpen()
            sendSetupMessage(ws)
        }

        override fun onMessage(ws: WebSocket, text: String) {
            if (state == ClientState.AWAITING_SETUP_COMPLETE) {
                if (text.contains("\"setupComplete\"")) {
                    Log.d("WebSocketClient", "State -> READY")
                    state = ClientState.READY
                    listener.onSetupComplete()
                } else {
                    Log.w("WebSocketClient",
                        "Received unexpected message during setup: $text")
                }
            } else {
                listener.onMessage(text)
            }
        }

        override fun onClosing(ws: WebSocket, code: Int, reason: String) {
            state = ClientState.IDLE
            listener.onClose(reason)
        }

        override fun onFailure(ws: WebSocket, t: Throwable, response: Response?) {
            state = ClientState.IDLE
            listener.onError(t.message ?: "Unknown WebSocket error")
        }
    }

    private fun sendSetupMessage(ws: WebSocket) {
        state = ClientState.AWAITING_SETUP_COMPLETE
        Log.d("WebSocketClient", "State -> AWAITING_SETUP_COMPLETE")
        val setupMessage = mapOf("setup" to mutableMapOf<String, Any>().apply {
            put("model", "models/${config.modelName}")
            put("generationConfig", mapOf("responseModalities" to listOf("AUDIO")))
            put("systemInstruction",
                createSystemInstruction(config.systemInstruction))
            put("inputAudioTranscription", emptyMap<String, Any>())
            put("outputAudioTranscription", emptyMap<String, Any>())
            put("contextWindowCompression",
                mapOf("slidingWindow" to emptyMap<String, Any>()))
            put("realtimeInputConfig", mapOf(
                "automaticActivityDetection" to mapOf(
                    "silenceDurationMs" to config.vadSilenceMs)
            ))
            config.sessionHandle?.let { handle ->
                put("sessionResumption", mapOf("handle" to handle))
            }
        })
        val setupJson = gson.toJson(setupMessage)
        Log.d("WebSocketClient", "Sending setup message...")
        ws.send(setupJson)
    }

    private fun createSystemInstruction(instruction: String): Map<String, Any> {
        return mapOf(
            "parts" to instruction.split(Regex("\n\n+")).map {
                mapOf("text" to it.trim())
            }
        )
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketInterceptor.kt --- 
package com.bwc.tul.data.websocket

import android.content.Context
import okhttp3.*
import okio.IOException
import com.bwc.tul.websocket.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import okhttp3.Response
class WebSocketInterceptor(
    private val context: Context,
    private val baseUrl: String
) : Interceptor {
    private val logger = WebSocketLogger(context)
    private val scope = CoroutineScope(Dispatchers.IO)

    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val response = chain.proceed(request)

        return if (isWebSocketUpgrade(response)) {
            return response.newBuilder()
                .build()
        } else {
            response
        }
    }

    private fun isWebSocketUpgrade(response: Response): Boolean {
        return response.code == 101 &&
                response.header("Connection")?.equals("Upgrade", ignoreCase = true) == true &&
                response.header("Upgrade")?.equals("websocket", ignoreCase = true) == true
    }

    private fun createEventListener(url: String): EventListener {
        return object : EventListener() {
            override fun callStart(call: Call) {
                super.callStart(call)
                scope.launch {
                    logger.logSentMessage(url, "WebSocket connection initiated")
                }
            }

            override fun callEnd(call: Call) {
                super.callEnd(call)
                scope.launch {
                    logger.logSentMessage(url, "WebSocket connection closed")
                }
            }

            override fun callFailed(call: Call, ioe: IOException) {
                super.callFailed(call, ioe)
                scope.launch {
                    logger.logSentMessage(url, "WebSocket connection failed: ${ioe.message}")
                }
            }
        }
    }

    fun shutdown() {
        scope.coroutineContext.cancel()
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketLogExporter.kt --- 
package com.bwc.tul.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import com.bwc.tul.data.websocket.WebSocketLogger
import kotlinx.coroutines.launch
import java.io.File

@Composable
fun WebSocketLogExporter(
    modifier: Modifier = Modifier,
    onExportComplete: (File) -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    var isExporting by remember { mutableStateOf(false) }

    Button(
        onClick = {
            isExporting = true
            scope.launch {
                val file = WebSocketLogger(context).exportLogs()
                onExportComplete(file)
                isExporting = false
            }
        },
        modifier = modifier,
        enabled = !isExporting
    ) {
        if (isExporting) {
            CircularProgressIndicator(Modifier.size(ButtonDefaults.IconSize))
            Spacer(Modifier.width(8.dp))
            Text("Exporting...")
        } else {
            Text("Export WebSocket Logs")
        }
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketLogger.kt --- 
package com.bwc.tul.data.websocket


import androidx.room.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.File
import java.util.*
import android.content.Context
import com.bwc.tul.data.AppDatabase
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import com.bwc.tul.websocket.*


class WebSocketLogger(private val context: Context) {
    private val dao = AppDatabase.getDatabase(context).webSocketLogDao()

    suspend fun logSentMessage(url: String, message: String) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.SENT,
                url = url,
                message = message
            )
        )
    }

    suspend fun logReceivedMessage(url: String, message: String) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.RECEIVED,
                url = url,
                message = if (isAudioMessage(message)) "[AUDIO DATA]" else message
            )
        )
    }

    suspend fun getLogs(limit: Int = 200): List<WebSocketLogEntry> = withContext(Dispatchers.IO) {
        dao.getRecentLogs(limit)
    }

    suspend fun exportLogs(): File = withContext(Dispatchers.IO) {
        val logs = dao.getAllLogs()
        val file = File(context.cacheDir, "websocket_logs_${System.currentTimeMillis()}.txt")

        file.writeText(buildString {
            logs.forEach { log ->
                appendLine("[${Date(log.timestamp)}] ${log.direction} ${log.url}")
                if (log.isError) {
                    appendLine("ERROR: ${log.errorMessage}")
                }
                appendLine(log.message)
                appendLine("=".repeat(80))
            }
        })
        file
    }

    private fun isAudioMessage(message: String): Boolean {
        return try {
            if (message.startsWith("{")) {
                val json = JSONObject(message)
                json.has("audio") || json.optString("contentType").contains("audio", ignoreCase = true)
            } else {
                message.contains("content-type: audio", ignoreCase = true)
            }
        } catch (e: Exception) {
            false
        }
    }
} 
