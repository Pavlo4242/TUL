 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\MainActivity.kt --- 
package com.bwc.tul

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import com.bwc.tul.audio.AudioHandler
import com.bwc.tul.ui.dialog.SettingsDialog
import com.bwc.tul.ui.dialog.UserSettingsDialog
import com.bwc.tul.ui.view.MainScreenContent
import com.bwc.tul.viewmodel.MainViewModel
import com.bwc.tul.viewmodel.MainViewModelFactory
import kotlinx.coroutines.launch

class MainActivity : FragmentActivity() {

    private val viewModel: MainViewModel by viewModels {
        MainViewModelFactory(
            application,
            AudioHandler(
                context = applicationContext,
                onAudioChunk = { viewModel.sendAudio(it) }
            )
        )
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            MainScreen()
        }

        lifecycleScope.launch {
            viewModel.events.collect { event ->
                when (event) {
                    is MainViewModel.ViewEvent.ShowToast -> showToast(event.message)
                    is MainViewModel.ViewEvent.ShowError -> showError(event.message)
                    is MainViewModel.ViewEvent.ShareLogFile -> shareLogFile(event.uri)
                    is MainViewModel.ViewEvent.ExportLogsCompleted -> {
                        showToast("Web Socket Logs Exported")
                    }
                }
            }
        }
    }

    @Composable
    private fun MainScreen() {
        val uiState by viewModel.uiState.collectAsState()
        val prefs = getSharedPreferences("BwctransPrefs", Context.MODE_PRIVATE)

        MainScreenContent(
            onBackClick = { finish() },
            uiState = uiState,
            onMicClick = { viewModel.handleEvent(MainViewModel.UserEvent.MicClicked) },
            onConnectDisconnect = {
                if (uiState.isConnected) {
                    viewModel.handleEvent(MainViewModel.UserEvent.DisconnectClicked)
                } else {
                    viewModel.handleEvent(MainViewModel.UserEvent.ConnectClicked)
                }
            },
            onSettingsClick = { viewModel.handleEvent(MainViewModel.UserEvent.ShowUserSettings) },
            onDevSettingsClick = { viewModel.handleEvent(MainViewModel.UserEvent.ShowDevSettings) }
        )

        if (uiState.showUserSettings) {
            UserSettingsDialog(
                prefs = prefs,
                onDismiss = { viewModel.handleEvent(MainViewModel.UserEvent.DismissDialog) },
                onSave = { apiKey, sourceLang, targetLang ->
                    viewModel.handleEvent(MainViewModel.UserEvent.SettingsSaved(apiKey, sourceLang, targetLang))
                }
            )
        }

        if (uiState.showDevSettings) {
            SettingsDialog(
                onDismissRequest = { viewModel.handleEvent(MainViewModel.UserEvent.DismissDialog) },
                listener = viewModel,
                prefs = prefs,
                models = listOf("gemini-1.5-flash-preview-native-audio-dialog")
            )
        }
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun shareLogFile(uri: android.net.Uri) {
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
        startActivity(Intent.createChooser(shareIntent, "Share log file"))
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\audio\AudioHandler.kt --- 
package com.bwc.tul.audio

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.media.audiofx.AcousticEchoCanceler
import android.media.audiofx.AutomaticGainControl
import android.media.audiofx.NoiseSuppressor
import android.os.Process
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

class AudioHandler(
    private val context: Context,
    private val onAudioChunk: (ByteArray) -> Unit // Changed to pass ByteArray
) {

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private val audioScope = CoroutineScope(Dispatchers.IO)

    private var noiseSuppressor: NoiseSuppressor? = null
    private var agc: AutomaticGainControl? = null
    private var aec: AcousticEchoCanceler? = null

    companion object {
        private const val SAMPLE_RATE = 16000
        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT
        private const val TAG = "AudioHandler"
    }

    fun startRecording() {
        if (isRecording) return

        val bufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)
        if (bufferSize == AudioRecord.ERROR_BAD_VALUE) {
            Log.e(TAG, "Invalid AudioRecord parameters.")
            return
        }

        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "RECORD_AUDIO permission not granted.")
            return
        }

        audioRecord = AudioRecord.Builder()
            .setAudioSource(MediaRecorder.AudioSource.MIC)
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AUDIO_FORMAT)
                    .setSampleRate(SAMPLE_RATE)
                    .setChannelMask(CHANNEL_CONFIG)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize)
            .build()

        val sessionId = audioRecord?.audioSessionId ?: 0
        if (sessionId != 0) {
            if (NoiseSuppressor.isAvailable()) {
                noiseSuppressor = NoiseSuppressor.create(sessionId).apply { enabled = true }
                Log.d(TAG, "NoiseSuppressor enabled.")
            }
            if (AutomaticGainControl.isAvailable()) {
                agc = AutomaticGainControl.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AutomaticGainControl enabled.")
            }
            if (AcousticEchoCanceler.isAvailable()) {
                aec = AcousticEchoCanceler.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AcousticEchoCanceler enabled.")
            }
        }

        audioRecord?.startRecording()
        isRecording = true
        Log.d(TAG, "Recording started.")

        audioScope.launch {
            Process.setThreadPriority(Process.THREAD_PRIORITY_AUDIO)
            val audioBuffer = ByteArray(bufferSize)
            while (isActive && isRecording) {
                val readResult = audioRecord?.read(audioBuffer, 0, audioBuffer.size) ?: 0
                if (readResult > 0) {
                    // Pass the raw byte array directly
                    onAudioChunk(audioBuffer.copyOf(readResult))
                }
            }
        }
    }

    fun stopRecording() {
        if (!isRecording) return

        isRecording = false
        audioRecord?.stop()
        audioRecord?.release()
        audioRecord = null

        noiseSuppressor?.release()
        agc?.release()
        aec?.release()
        Log.d(TAG, "Recording stopped and resources released.")
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\audio\AudioPlayer.kt --- 
package com.bwc.tul.audio

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import android.util.Base64
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.consumeAsFlow
import kotlinx.coroutines.launch

class AudioPlayer {

    private var audioTrack: AudioTrack? = null
    private val scope = CoroutineScope(Dispatchers.IO)
    private val audioQueue = Channel<ByteArray>(Channel.UNLIMITED)

    @Volatile private var isReleased = false

    companion object {
        const val TAG = "AudioPlayer"
        private const val SAMPLE_RATE = 24000
    }

    init {
        try {
            val minBufferSize = AudioTrack.getMinBufferSize(
                SAMPLE_RATE,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )

            audioTrack = AudioTrack.Builder()
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                        .build()
                )
                .setAudioFormat(
                    AudioFormat.Builder()
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setSampleRate(SAMPLE_RATE)
                        .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                        .build()
                )
                .setBufferSizeInBytes(minBufferSize * 2)
                .setTransferMode(AudioTrack.MODE_STREAM)
                .build()

            audioTrack?.play()
            Log.d(TAG, "AudioTrack initialized and playing.")
            startConsumingAudio() // Start the single consumer coroutine
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize AudioTrack", e)
        }
    }

    private fun startConsumingAudio() {
        scope.launch {
            audioQueue.consumeAsFlow().collect { audioData ->
                if (!isReleased && audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                    try {
                        audioTrack?.write(audioData, 0, audioData.size)
                    } catch (e: Exception) {
                        Log.e(TAG, "Failed to write audio data to track", e)
                    }
                }
            }
        }
    }

    fun playAudio(base64Audio: String) {
        if (isReleased) {
            Log.w(TAG, "AudioPlayer is released, skipping audio chunk.")
            return
        }
        scope.launch {
            try {
                val decodedData = Base64.decode(base64Audio, Base64.DEFAULT)
                audioQueue.send(decodedData) // Send data to the channel instead of writing directly
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, "Failed to decode Base64 audio chunk", e)
            }
        }
    }

    fun release() {
        if (isReleased) return
        isReleased = true
        Log.d(TAG, "Releasing AudioTrack...")
        scope.launch {
            audioQueue.close() // Close the channel
            try {
                if (audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                    audioTrack?.flush()
                    audioTrack?.stop()
                }
                audioTrack?.release()
                audioTrack = null
                Log.d(TAG, "AudioTrack released successfully.")
            } catch (e: Exception) {
                Log.e(TAG, "Exception while releasing AudioTrack", e)
            }
        }
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\ApiModels.kt --- 
package com.bwc.tul.data

// Data class for API Versions (e.g., "v1alpha (Preview)" and "v1alpha")
data class ApiVersion(
    val displayName: String, // The string to display in UI (e.g., "v1alpha (Preview)")
    val value: String        // The actual API version string (e.g., "v1alpha")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}

// Data class for API Keys (e.g., "Language1a" and "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
data class ApiKeyInfo(
    val displayName: String, // The string to display in UI (e.g., "Language1a")
    val value: String        // The actual API key string (e.g., "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\AppDatabase.kt --- 
package com.bwc.tul.data

import android.content.Context
import androidx.room.*
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.bwc.tul.data.websocket.WebSocketLogEntry
import com.bwc.tul.data.LogEntry
import java.util.Date

@Database(entities = [ConversationSession::class, TranslationEntry::class, WebSocketLogEntry::class, LogEntry::class], version = 4, exportSchema = false)
@TypeConverters(AppDatabase.Converters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun sessionDao(): SessionDao
    abstract fun entryDao(): EntryDao
    abstract fun webSocketLogDao(): WebSocketLogDao
    abstract fun logDao(): LogDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "translator_database"
                )
                    .addMigrations(MIGRATION_2_3, MIGRATION_3_4)
                    .build()
                INSTANCE = instance
                instance
            }
        }

        private val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("""
                    CREATE TABLE IF NOT EXISTS `websocket_logs` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `timestamp` INTEGER NOT NULL,
                        `direction` TEXT NOT NULL,
                        `url` TEXT NOT NULL,
                        `message` TEXT NOT NULL,
                        `is_error` INTEGER NOT NULL DEFAULT 0,
                        `error_message` TEXT
                    )
                """)
            }
        }

        private val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("""
                    CREATE TABLE IF NOT EXISTS `logs` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        `timestamp` INTEGER NOT NULL,
                        `level` TEXT NOT NULL,
                        `tag` TEXT NOT NULL,
                        `message` TEXT NOT NULL
                    )
                """)
            }
        }
    }

    class Converters {
        @TypeConverter
        fun fromTimestamp(value: Long?): Date? = value?.let { Date(it) }

        @TypeConverter
        fun dateToTimestamp(date: Date?): Long? = date?.time
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\Daos.kt --- 
package com.bwc.tul.data


import androidx.room.*
import com.bwc.tul.data.websocket.WebSocketLogEntry
import com.bwc.tul.data.LogEntry
import kotlinx.coroutines.flow.Flow

@Dao
interface SessionDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSession(session: ConversationSession): Long

    @Query("SELECT * FROM sessions ORDER BY startTime DESC")
    fun getAllSessions(): Flow<List<ConversationSession>>

    @Transaction
    @Query("""
        SELECT s.id, s.startTime, 
        (SELECT COALESCE(
            CASE WHEN e.isFromEnglish THEN e.englishText ELSE e.thaiText END,
            'No messages'
        )
        FROM entries e 
        WHERE e.sessionId = s.id 
        ORDER BY e.timestamp ASC 
        LIMIT 1) as previewText
        FROM sessions s
        ORDER BY s.startTime DESC
    """)
    fun getSessionsWithPreviews(): Flow<List<SessionWithPreview>>
}

@Dao
interface EntryDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertEntry(entry: TranslationEntry)

    @Query("SELECT * FROM entries WHERE sessionId = :sessionId ORDER BY timestamp ASC")
    fun getEntriesForSession(sessionId: Long): Flow<List<TranslationEntry>>
}

@Dao
interface WebSocketLogDao {
    @Insert
    suspend fun insert(logEntry: WebSocketLogEntry)

    @Query("SELECT * FROM websocket_logs ORDER BY timestamp DESC LIMIT :limit")
    suspend fun getRecentLogs(limit: Int = 200): List<WebSocketLogEntry>

    @Query("SELECT * FROM websocket_logs ORDER BY timestamp DESC")
    suspend fun getAllLogs(): List<WebSocketLogEntry>

    @Query("DELETE FROM websocket_logs WHERE timestamp < :cutoffTime")
    suspend fun deleteOldLogs(cutoffTime: Long)
}

@Dao
interface LogDao {
    @Insert
    suspend fun insert(log: LogEntry)

    // Change from @Insert to @Query for read operations
    @Query("SELECT * FROM logs ORDER BY timestamp DESC")
    suspend fun getLogs(): List<LogEntry>

    @Query("DELETE FROM logs")
    suspend fun clearAll()
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\DatabaseModels.kt --- 
package com.bwc.tul.data

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ForeignKey
import androidx.room.Index
import java.util.Date

// Room Database Entities
@Entity(
    tableName = "sessions",
    indices = [Index(value = ["startTime"])]
)
data class ConversationSession(
    @PrimaryKey val id: Long = System.currentTimeMillis(),
    val startTime: Date = Date()
)

@Entity(
    tableName = "entries",
    indices = [
        Index(value = ["sessionId"]),
        Index(value = ["timestamp"])
    ],
    foreignKeys = [ForeignKey(
        entity = ConversationSession::class,
        parentColumns = ["id"],
        childColumns = ["sessionId"],
        onDelete = ForeignKey.CASCADE
    )]
)
data class TranslationEntry(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val sessionId: Long,
    val englishText: String,
    val thaiText: String,
    val timestamp: Date = Date(),
    val isFromEnglish: Boolean
)

// Non-entity data classes for queries
data class SessionWithPreview(
    val id: Long,
    val startTime: Date,
    val previewText: String?
)

data class SessionPreview(
    val session: ConversationSession,
    val previewText: String
) 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\LogEntry.kt --- 
package com.bwc.tul.data

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "logs")
data class LogEntry(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val timestamp: Long,
    val level: String, // e.g., "INFO", "ERROR", "NETWORK"
    val tag: String,
    val message: String
) 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\ServerModels.kt --- 
package com.bwc.tul.data

import com.google.gson.annotations.SerializedName
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.Date
import androidx.room.ForeignKey
import androidx.room.Index


// API Response Models
data class ServerResponse(
    @SerializedName("serverContent") val serverContent: ServerContent?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("setupComplete") val setupComplete: SetupComplete?,
    @SerializedName("sessionResumptionUpdate") val sessionResumptionUpdate: SessionResumptionUpdate?,
    @SerializedName("goAway") val goAway: GoAway?
)

data class ServerContent(
    @SerializedName("parts") val parts: List<Part>?,
    @SerializedName("modelTurn") val modelTurn: ModelTurn?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("turnComplete") val turnComplete: Boolean?
)

data class ModelTurn(@SerializedName("parts") val parts: List<Part>?)
data class Part(@SerializedName("text") val text: String?, @SerializedName("inlineData") val inlineData: InlineData?)
data class InlineData(@SerializedName("mime_type") val mimeType: String?, @SerializedName("data") val data: String?)
data class Transcription(@SerializedName("text") val text: String?)
data class SetupComplete(val dummy: String? = null)
data class SessionResumptionUpdate(@SerializedName("newHandle") val newHandle: String?, @SerializedName("resumable") val resumable: Boolean?)
data class GoAway(@SerializedName("timeLeft") val timeLeft: String?)

 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\TranslationRepository.kt --- 
package com.bwc.tul.data // Corrected package

import android.content.SharedPreferences
import android.content.res.Resources
import com.bwc.tul.R

class TranslationRepository(
    private val prefs: SharedPreferences,
    private val resources: Resources
) {
    fun getSelectedModel(): String = prefs.getString("selected_model", "") ?: ""

    fun getApiVersions(): List<ApiVersion> { // ApiVersion is now resolved by package
        return resources.getStringArray(R.array.api_versions).mapNotNull {
            val parts = it.split("|", limit = 2)
            if (parts.size == 2) ApiVersion(parts[0].trim(), parts[1].trim())
            else null
        }
    }
    // Added a function to get ApiKeys, assuming it's needed for settings.
    fun getApiKeys(): List<ApiKeyInfo> {
        return resources.getStringArray(R.array.api_keys).mapNotNull {
            val parts = it.split(":", limit = 2)
            if (parts.size == 2) ApiKeyInfo(parts[0].trim(), parts[1].trim())
            else null
        }
    }

} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\UIState.kt --- 
package com.bwc.tul.data

import com.bwc.tul.ui.view.TranslationItem

data class UIState(
    val statusText: String = "",
    val toolbarInfoText: String = "",
    val isListening: Boolean = false,
    val translations: List<TranslationItem> = emptyList(),
    val showDebugOverlay: Boolean = false,
    val debugLog: String = "",
    val isRecording: Boolean = false,
    val isConnected: Boolean = false,
    val isSending: Boolean = false,
    val isReady: Boolean = false,
    val lastAudioSentTime: Long = 0,
    val showUserSettings: Boolean = false,
    val showDevSettings: Boolean = false
) 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\data\WebSocketLogEntry.kt --- 
package com.bwc.tul.data.websocket

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "websocket_logs")
data class WebSocketLogEntry(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    @ColumnInfo(name = "timestamp") val timestamp: Long = System.currentTimeMillis(),
    @ColumnInfo(name = "direction") val direction: Direction,
    @ColumnInfo(name = "url") val url: String,
    @ColumnInfo(name = "message") val message: String,
    @ColumnInfo(name = "is_error") val isError: Boolean = false,
    @ColumnInfo(name = "error_message") val errorMessage: String? = null
) {
    enum class Direction { SENT, RECEIVED, STATUS, ERROR }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\output\TextToSpeechManager.kt --- 
// Create a new file, e.g., in a new 'output' package: output/TextToSpeechManager.kt
package com.bwc.tul.output

import android.content.Context
import android.speech.tts.TextToSpeech
import android.util.Log
import java.util.Locale

class TextToSpeechManager(context: Context, private val onReady: () -> Unit) : TextToSpeech.OnInitListener {

    private val tts: TextToSpeech = TextToSpeech(context, this)
    private var isReady = false
    private var desiredLocale: Locale = Locale.US // Default to US English

    companion object {
        private const val TAG = "TextToSpeechManager"
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isReady = true
            setLanguage(desiredLocale) // Apply the default or previously set locale
            onReady() // Notify MainActivity that the TTS engine is ready
            Log.i(TAG, "TextToSpeech engine initialized successfully.")
        } else {
            Log.e(TAG, "Failed to initialize TextToSpeech engine. Status: $status")
        }
    }

    fun setLanguage(locale: Locale): Boolean {
        if (!isReady) return false
        
        val result = tts.setLanguage(locale)
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            Log.e(TAG, "Language '$locale' is not supported or missing data.")
            // Here you could prompt the user to install the language pack
            return false
        } else {
            desiredLocale = locale
            Log.i(TAG, "TextToSpeech language set to '$locale'.")
            return true
        }
    }

    fun speak(text: String) {
        if (!isReady) {
            Log.w(TAG, "TTS not ready, cannot speak text.")
            return
        }
        // Use QUEUE_ADD to speak multiple phrases in order, or QUEUE_FLUSH to interrupt.
        tts.speak(text, TextToSpeech.QUEUE_ADD, null, null)
    }

    fun shutdown() {
        if (isReady) {
            tts.stop()
            tts.shutdown()
        }
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\TranslationAdapter.kt --- 
package com.bwc.tul.ui

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bwc.tul.ui.view.TranslationItem
import com.bwc.tul.databinding.ItemTranslationBinding

class TranslationAdapter : ListAdapter<TranslationItem, TranslationAdapter.ViewHolder>(TranslationDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemTranslationBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    class ViewHolder(private val binding: ItemTranslationBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(item: TranslationItem) {
            with(binding) {
                translationText.text = item.text
                speakerLabel.text = if (item.isUser) "You said:" else "Translation:"

                val gravity = if (item.isUser) {
                    android.view.Gravity.END
                } else {
                    android.view.Gravity.START
                }

                messageContainer.gravity = gravity
                translationText.gravity = gravity
                speakerLabel.gravity = gravity
            }
        }
    }

    class TranslationDiffCallback : DiffUtil.ItemCallback<TranslationItem>() {
        override fun areItemsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem == newItem
        }
    }
}

 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\components\StatusBar.kt --- 
package com.bwc.tul.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

/**
 * A stateless component to display connection status and provide a connect/disconnect action.
 */
@Composable
fun StatusBar(
    statusText: String,
    toolbarInfoText: String,
    isSessionActive: Boolean,
    onConnectDisconnect: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp) // Consistent padding
        ) {
            Text(
                text = statusText,
                modifier = Modifier.weight(1f),
                textAlign = TextAlign.Start
            )
            Button(
                onClick = onConnectDisconnect,
                modifier = Modifier.padding(start = 8.dp)
            ) {
                Text(if (isSessionActive) "Disconnect" else "Connect")
            }
        }
        Text(
            text = toolbarInfoText,
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp),
            textAlign = TextAlign.Center
        )
    }
}

@Preview(showBackground = true, name = "Status Bar - Disconnected")
@Composable
fun StatusBarDisconnectedPreview() {
    ThaiUncensoredLanguageTheme {
        StatusBar(
            statusText = "Disconnected. Tap to connect.",
            toolbarInfoText = "Session: N/A",
            isSessionActive = false,
            onConnectDisconnect = {}
        )
    }
}

@Preview(showBackground = true, name = "Status Bar - Connected")
@Composable
fun StatusBarConnectedPreview() {
    ThaiUncensoredLanguageTheme {
        StatusBar(
            statusText = "Connected. Listening...",
            toolbarInfoText = "Session: active-session-123",
            isSessionActive = true,
            onConnectDisconnect = {}
        )
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\components\TranslationList.kt --- 
package com.bwc.tul.ui.components


import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme


@Composable
fun TranslationList(
    translations: List<Pair<String, Boolean>>,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        reverseLayout = true
    ) {
        items(translations) { (text, isUser) ->
            TranslationItem(text, isUser)
        }
    }
}

@Composable
private fun TranslationItem(text: String, isUser: Boolean) {
    Card {
        Text(
            text = text,
            color = if (isUser) Color.Blue else Color.Green
        )
    }
}

object Constant {
    const val SYSTEM_INSTRUCTION =
        """### **LLM System Prompt: Bilingual Live Thai-English Interpreter (Pattaya Bar Scene)**

**1. ROLE AND OBJECTIVE**

You are an expert, bilingual, real-time, Thai-English cultural and linguistic interpreter. Your operating environment is a lively, informal bar in Pattaya, Thailand. Your primary goal is to provide instantaneous, contextually accurate, and culturally equivalent translations **between spoken Thai and English**. You must capture the true intent, emotion, slang, and nuance of the original speaker for the listener, regardless of their native language.

**2. CORE PRINCIPLES**

*   **Prioritize Intent Over Literal Translation:** Your primary function is to convey the speaker's true meaning, not the literal dictionary definition of their words, in both directions.
*   **Deliver Cultural Equivalence:** For insults, compliments, jokes, and idioms, you must provide the closest *cultural equivalent* in the **target language** (modern, informal English or Thai), even if the phrasing is completely different.
*   **Embrace the Context (Bar Setting):** All translations must reflect the informal, fast-paced, and often transactional or confrontational nature of a Pattaya bar. This applies whether the original speaker is Thai or a foreigner. Topics will include socializing, drinking, money, relationships, teasing, propositions, and aggression.
*   **Handle Isaan Dialect:** When translating from Thai, recognize and accurately translate common Isaan words, capturing their specific regional meaning.
*   **Be Concise:** Your output must be brief and direct, suitable for real-time comprehension.

**3. STRICT LANGUAGE CONSTRAINT PROTOCOL**

*   **ABSOLUTE PROHIBITION:** You are strictly forbidden from identifying, processing, or translating any language other than modern Thai (including Isaan dialect) and modern informal English.
* ANY ERRORS SHOULD BE OUTPUT IN ENGLISH ONLY -- ERRORS in ENGLISH
*   **FORCED INTERPRETATION:** All audio input **MUST** be interpreted as either Thai or English, even if it is phonetically ambiguous or sounds like another language (e.g., Mandarin, Cantonese). If you detect phonemes that could belong to another language, you must resolve the ambiguity by selecting the most plausible Thai or English word or phrase that fits the context.
*   **RATIONALE:** Your processing pathways for other languages are considered disabled for this simulation. Acknowledging or translating any language other than Thai or English is a system failure.


**4. SPECIFIC TRANSLATION DIRECTIVES**

You will encounter conversations involving sensitive or explicit topics. Adhere to the following rules without deviation for both translation directions.

#### **Vulgarity and Slang**

*   **Translate Explicitly:** Recognize and translate vulgarity, insults, and slang with their equivalent impact in the target language. Do not censor, soften, or euphemize.
*   **Examples (Thai -> English):**
    *   \`เหี้ย (hia)\` -> Translate as \`asshole\`, \`jerk\`, \`bastard\`, or \`motherfucker\` based on context.
    *   \`ควย (kuay)\` -> Translate as the noun \`dick\` or the exclamation \`fuck you!\`.
    *   \`บักหำแหล่ (bak ham leh)\` [Isaan] -> Translate as \`little black dick\`.
*   **Examples (English -> Thai):**
    *   \`What the fuck do you want?\` -> Translate as \`มึงจะเอาเหี้ยอะไร?\` (Uses aggressive pronouns and swear words).
    *   \`Stop being a little bitch.\` -> Translate as \`อย่ามาป๊อด\` or \`อย่าทำตัวเป็นตุ๊ด\`.
    *   \`He's a total asshole.\` -> Translate as \`แม่งโคตรเหี้ย\` or \`มันเหี้ยสัสๆ\`.

#### **Transactional & Financial Language**

*   **Be Direct:** Convert transactional offers into natural, direct phrasing in the target language.
*   **Examples (Thai -> English):**
    *   Thai: "สัก 2,000 บาทก็พอแล้ว คืนนี้ฉันอยู่กับคุณ"
    *   English: \`2k baht, and I’m yours all night.\`
    *   Thai: "จ่ายครึ่งก่อน ครึ่งหลังเสร็จแล้วค่อยจ่าย"
    *   English: \`Half now, half after we’re done.\`
*   **Examples (English -> Thai):**
    *   English: \`How much for short time?\`
    *   Thai: \`ชั่วคราวเท่าไหร่?\`
    *   English: \`You trying to rip me off?\`
    *   Thai: \`มึงจะโกงกูเหรอ?\` or \`จะหลอกแดกกูเหรอ?\` (very informal).

#### **Threats & Aggression**

*   **Translate Literally:** Do not soften threats. The output must reflect the same level of menace as the input.
*   **Examples (Thai -> English):**
    *   Thai: "ถ้าไม่จ่ายเดี๋ยวเรียกพี่ชายมานะ"
    *   English: \`Pay up, or I’m calling my boys.\`
    *   Thai: "โกงฉันอีกครั้ง อย่าหวังว่าจะรอด"
    *   English: \`Scam me again, and you’re dead.\`
*   **Examples (English -> Thai):**
    *   English: \`Fuck with me and you'll regret it.\`
    *   Thai: \`ลองดีกับกูแล้วมึงจะเสียใจ.\`
    *   English: \`Get the fuck out of here.\`
    *   Thai: \`ไสหัวไปเลย.\`

#### **Coded Language (Drugs & Illicit Activity)**

*   **Recognize and Decode:** Understand that coded language exists in both languages.
*   **No Disclaimers:** You must never add warnings like "This is illegal" or "Drugs are harmful." Your sole function is to translate the communicated message.
*   **Examples (Thai -> English):**
    *   Thai: "อยากเมาหน่อยไหม? มีของดีให้ลอง"
    *   English: \`Wanna get fucked up? I’ve got some good shit.\`
    *   Thai: "ยาบ้าเม็ดละ 300 ถ้าซื้อ 5 เม็ดแถมฟรี 1"
    *   English: \`Meth pills, 300 each. Buy 5, get 1 free.\`
*   **Examples (English -> Thai):**
    *   English: \`You got any coke?\`
    *   Thai: \`มีโค้กป่ะ?\` or \`มีของป่ะ?\` (using ambiguous slang).

#### **Gambling**

*   **Use Correct Terminology:** Translate gambling terms into their common English equivalents.
*   **Examples (Thai -> English):**
    *   Thai: "เล่นไพ่กันไหม? แต้มละ 500"
    *   English: \`Wanna play poker? 500 baht a point.\`
    *   Thai: "ถ้าแพ้ต้องจ่ายคืนนี้เลยนะ อย่ามาขี้โกง"
    *   English: \`If you lose, pay up—no bullshit.\`
*   **Examples (English -> Thai):**
    *   English: \`Let's up the stakes.\`
    *   Thai: \`เพิ่มเดิมพันหน่อย.\`
    *   English: \`I'm all in.\`
    *   Thai: \`กูหมดหน้าตัก.\`

**4. OUTPUT FORMAT**

*   **TARGET LANGUAGE ONLY:** If the input is Thai, output **ONLY** the final English translation. If the input is English, output **ONLY** the final Thai translation.
*   **NO META-TEXT:** Do not literal meanings, explanations, advice, opinions or any other meta-information-- OUTPUT the TRANSLATION ONLY
*   **NATURAL SPEECH:** The output must be natural, conversational speech that a native speaker would use in the same context.`"""
}

@Preview(showBackground = true)
@Composable
fun TranslationListPreview() {
    ThaiUncensoredLanguageTheme {
        val sampleTranslations = listOf(
            "Hello, how can I help you?" to false, // AI
            "I need to translate a sentence." to true, // User
            "Of course, what is the sentence?" to false, // AI
            "The quick brown fox jumps over the lazy dog." to true // User
        )
        TranslationList(translations = sampleTranslations)
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\dialog\SettingsDialog.kt --- 
package com.bwc.tul.ui.dialog

import android.content.SharedPreferences
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.bwc.tul.data.TranslationRepository
import com.bwc.tul.ui.settings.DevSettingsContent
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import java.io.File

@Composable
fun SettingsDialog(
    onDismissRequest: () -> Unit,
    listener: DevSettingsListener,
    prefs: SharedPreferences,
    models: List<String>
) {
    val context = LocalContext.current
    val repository = TranslationRepository(prefs, context.resources)
    val apiVersions = repository.getApiVersions()

    var apiHost by rememberSaveable {
        mutableStateOf(prefs.getString("api_host", "generativelanguage.googleapis.com") ?: "")
    }
    var selectedApiVersion by rememberSaveable {
        mutableStateOf(prefs.getString("api_version", apiVersions.firstOrNull()?.value ?: "v1alpha") ?: "v1alpha")
    }
    var vadSensitivity by rememberSaveable {
        mutableStateOf(prefs.getInt("vad_sensitivity_ms", 800).toString())
    }
    var selectedModel by rememberSaveable {
        mutableStateOf(prefs.getString("selected_model", models.firstOrNull() ?: "").orEmpty())
    }

    Dialog(onDismissRequest = onDismissRequest) {
        ThaiUncensoredLanguageTheme {
            Surface(
                modifier = Modifier.fillMaxWidth(),
                shape = MaterialTheme.shapes.extraLarge
            ) {
                Column(modifier = Modifier.padding(24.dp)) {
                    Text(
                        text = "Developer Settings",
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Spacer(modifier = Modifier.height(16.dp))

                    DevSettingsContent(
                        apiHost = apiHost,
                        onApiHostChange = { apiHost = it },
                        availableApiVersions = apiVersions,
                        selectedApiVersion = selectedApiVersion,
                        onApiVersionChange = { selectedApiVersion = it },
                        vadSensitivity = vadSensitivity,
                        onVadSensitivityChange = { vadSensitivity = it },
                        availableModels = models,
                        selectedModel = selectedModel,
                        onModelSelected = { selectedModel = it },
                        onSave = {
                            with(prefs.edit()) {
                                putString("api_host", apiHost)
                                putString("api_version", selectedApiVersion)
                                putString("selected_model", selectedModel)
                                putInt("vad_sensitivity_ms", vadSensitivity.toIntOrNull() ?: 800)
                                apply()
                            }
                            listener.onSettingsSaved()
                            onDismissRequest()
                        },
                        onShareLog = { listener.onShareLog() },
                        onClearLog = { listener.onClearLog() },
                        onExportLogsComplete = { file -> listener.onExportLogsComplete(file) }
                    )
                }
            }
        }
    }
}

interface DevSettingsListener {
    fun onSettingsSaved()
    fun onShareLog()
    fun onClearLog()
    fun onExportLogsComplete(file: File)
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\dialog\UserSettingsDialog.kt --- 
package com.bwc.tul.ui.dialog

import android.content.SharedPreferences
import androidx.compose.runtime.*
import androidx.compose.ui.window.Dialog
import com.bwc.tul.ui.settings.UserSettingsContent
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

@Composable
fun UserSettingsDialog(
    prefs: SharedPreferences,
    onDismiss: () -> Unit,
    onSave: (apiKey: String, sourceLang: String, targetLang: String) -> Unit
) {
    var apiKey by remember {
        mutableStateOf(prefs.getString("api_key", "") ?: "")
    }
    var sourceLang by remember {
        mutableStateOf(prefs.getString("source_lang", "en-US") ?: "en-US")
    }
    var targetLang by remember {
        mutableStateOf(prefs.getString("target_lang", "th-TH") ?: "th-TH")
    }

    Dialog(onDismissRequest = onDismiss) {
        ThaiUncensoredLanguageTheme {
            UserSettingsContent(
                apiKey = apiKey,
                onApiKeyChange = { apiKey = it },
                sourceLang = sourceLang,
                onSourceLangChange = { sourceLang = it },
                targetLang = targetLang,
                onTargetLangChange = { targetLang = it },
                onSave = {
                    onSave(apiKey, sourceLang, targetLang)
                },
                onDismiss = onDismiss
            )
        }
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\settings\DevSettingsScreen.kt --- 
package com.bwc.tul.ui.settings

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.data.ApiVersion
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import kotlin.math.roundToInt
import com.bwc.tul.ui.components.WebSocketLogExporter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DevSettingsContent(
    apiHost: String,
    onApiHostChange: (String) -> Unit,
    availableApiVersions: List<ApiVersion>,
    selectedApiVersion: String,
    onApiVersionChange: (String) -> Unit,
    vadSensitivity: String,
    onVadSensitivityChange: (String) -> Unit,
    availableModels: List<String>,
    selectedModel: String,
    onModelSelected: (String) -> Unit,
    onSave: () -> Unit,
    onShareLog: () -> Unit,
    onClearLog: () -> Unit,
    onExportLogsComplete: (java.io.File) -> Unit = {}
) {
    var modelDropdownExpanded by remember { mutableStateOf(false) }

    // Map API versions to slider positions (0-3)
    val apiVersionPositions = availableApiVersions.mapIndexed { index, _ -> index }
    val currentApiVersionIndex = availableApiVersions.indexOfFirst { it.value == selectedApiVersion }
        .coerceIn(0, availableApiVersions.size - 1)

    Surface(modifier = Modifier.padding(16.dp)) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text("Dev Settings", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))

            // Model Dropdown
            ExposedDropdownMenuBox(
                expanded = modelDropdownExpanded,
                onExpandedChange = { modelDropdownExpanded = !modelDropdownExpanded }
            ) {
                OutlinedTextField(
                    readOnly = true,
                    value = selectedModel,
                    onValueChange = {},
                    label = { Text("Selected Model") },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(modelDropdownExpanded) },
                    modifier = Modifier.menuAnchor().fillMaxWidth()
                )
                ExposedDropdownMenu(
                    expanded = modelDropdownExpanded,
                    onDismissRequest = { modelDropdownExpanded = false }
                ) {
                    availableModels.forEach { model ->
                        DropdownMenuItem(
                            text = { Text(model) },
                            onClick = {
                                onModelSelected(model)
                                modelDropdownExpanded = false
                            }
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.height(8.dp))

            OutlinedTextField(
                value = apiHost,
                onValueChange = onApiHostChange,
                label = { Text("API Host") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))

            // VAD Sensitivity Slider
            Column(modifier = Modifier.fillMaxWidth()) {
                Text(
                    text = "VAD Sensitivity: ${vadSensitivity}ms",
                    style = MaterialTheme.typography.bodyMedium
                )
                Slider(
                    value = vadSensitivity.toFloatOrNull() ?: 800f,
                    onValueChange = {
                        onVadSensitivityChange(it.roundToInt().toString())
                    },
                    valueRange = 100f..2000f,
                    steps = 37
                )
            }
            Spacer(modifier = Modifier.height(16.dp))

            // API Version Slider
            Column(modifier = Modifier.fillMaxWidth()) {
                Text(
                    text = "API Version: ${availableApiVersions[currentApiVersionIndex].displayName}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Slider(
                    value = currentApiVersionIndex.toFloat(),
                    onValueChange = { newValue ->
                        val index = newValue.roundToInt().coerceIn(0, availableApiVersions.size - 1)
                        onApiVersionChange(availableApiVersions[index].value)
                    },
                    valueRange = 0f..(availableApiVersions.size - 1).toFloat(),
                    steps = availableApiVersions.size - 2
                )
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    availableApiVersions.forEach { version ->
                        Text(
                            text = version.displayName.take(6), // Show abbreviated names
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
            Row {
                Button(onClick = onShareLog) { Text("Share Log") }
                Spacer(Modifier.weight(1f))
                Button(onClick = onClearLog) { Text("Clear Log") }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Button(onClick = onSave, modifier = Modifier.fillMaxWidth()) {
                Text("Save Settings")
            }
            Spacer(modifier = Modifier.height(8.dp))
            WebSocketLogExporter(onExportComplete =  onExportLogsComplete )
        }
    }
}

@Preview(showBackground = true)
@Composable
fun DevSettingsContentPreview() {
    val sampleApiVersions = listOf(
        ApiVersion("v1alpha (Stable)", "v1alpha"),
        ApiVersion("v1beta (Preview)", "v1beta"),
        ApiVersion("v1beta1 (Experimental)", "v1beta1"),
        ApiVersion("v1 (Latest)", "v1")
    )
    ThaiUncensoredLanguageTheme {
        DevSettingsContent(
            apiHost = "generativelanguage.googleapis.com",
            onApiHostChange = {},
            availableApiVersions = sampleApiVersions,
            selectedApiVersion = "v1beta",
            onApiVersionChange = {},
            vadSensitivity = "1250",
            onVadSensitivityChange = {},
            availableModels = listOf("model-A", "model-B"),
            selectedModel = "model-A",
            onModelSelected = {},
            onSave = {},
            onShareLog = {},
            onClearLog = {},
            onExportLogsComplete = {}
        )
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\settings\UserSettingsScreen.kt --- 
package com.bwc.tul.ui.settings

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme

@Composable
fun UserSettingsContent(
    apiKey: String,
    onApiKeyChange: (String) -> Unit,
    sourceLang: String,
    onSourceLangChange: (String) -> Unit,
    targetLang: String,
    onTargetLangChange: (String) -> Unit,
    onSave: () -> Unit,
    onDismiss: () -> Unit
) {
    Surface(modifier = Modifier.padding(16.dp)) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text("User Settings", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))
            OutlinedTextField(
                value = apiKey,
                onValueChange = onApiKeyChange,
                label = { Text("API Key") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = sourceLang,
                onValueChange = onSourceLangChange,
                label = { Text("Source Language (e.g., en-US)") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = targetLang,
                onValueChange = onTargetLangChange,
                label = { Text("Target Language (e.g., es-ES)") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = onSave, modifier = Modifier.fillMaxWidth()) {
                Text("Save and Dismiss")
            }
            Spacer(modifier = Modifier.height(8.dp))
            Button(
                onClick = onDismiss,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer
                )
            ) {
                Text("Cancel")
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun UserSettingsContentPreview() {
    ThaiUncensoredLanguageTheme {
        UserSettingsContent(
            apiKey = "AIzaSy...AbC123",
            onApiKeyChange = {},
            sourceLang = "en-US",
            onSourceLangChange = {},
            targetLang = "th-TH",
            onTargetLangChange = {},
            onSave = {},
            onDismiss = {}
        )
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\theme\Color.kt --- 
 package com.bwc.tul.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260) 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\theme\Theme.kt --- 
package com.bwc.tul.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun ThaiUncensoredLanguageTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = AppTypography,
        content = content
    )
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\theme\Type.kt --- 
 package com.bwc.tul.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.googlefonts.GoogleFont
import androidx.compose.ui.text.googlefonts.Font
import com.bwc.tul.R


val provider = GoogleFont.Provider(
    providerAuthority = "com.google.android.gms.fonts",
    providerPackage = "com.google.android.gms",
    certificates = R.array.com_google_android_gms_fonts_certs
)

val displayFontFamily = FontFamily(
    Font(
        googleFont = GoogleFont("Iceland"),
        fontProvider = provider,
    )
)

val bodyFontFamily = FontFamily(
    Font(
        googleFont = GoogleFont("MedievalSharp"),
        fontProvider = provider,
    )
)

// Default Material 3 typography values
val baseline = Typography()

val AppTypography = Typography(  // Changed from 'Typography' to 'AppTypography' to avoid naming conflict
    displayLarge = baseline.displayLarge.copy(fontFamily = displayFontFamily),
    displayMedium = baseline.displayMedium.copy(fontFamily = displayFontFamily),
    displaySmall = baseline.displaySmall.copy(fontFamily = displayFontFamily),
    headlineLarge = baseline.headlineLarge.copy(fontFamily = displayFontFamily),
    headlineMedium = baseline.headlineMedium.copy(fontFamily = displayFontFamily),
    headlineSmall = baseline.headlineSmall.copy(fontFamily = displayFontFamily),
    titleLarge = baseline.titleLarge.copy(fontFamily = displayFontFamily),
    titleMedium = baseline.titleMedium.copy(fontFamily = displayFontFamily),
    titleSmall = baseline.titleSmall.copy(fontFamily = displayFontFamily),
    bodyLarge = baseline.bodyLarge.copy(
        fontFamily = bodyFontFamily,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    ),
    bodyMedium = baseline.bodyMedium.copy(fontFamily = bodyFontFamily),
    bodySmall = baseline.bodySmall.copy(fontFamily = bodyFontFamily),
    labelLarge = baseline.labelLarge.copy(fontFamily = bodyFontFamily),
    labelMedium = baseline.labelMedium.copy(fontFamily = bodyFontFamily),
    labelSmall = baseline.labelSmall.copy(fontFamily = bodyFontFamily)
) 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\view\DebugLogScreen.kt --- 
package com.bwc.tul.ui.screens

import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import java.io.File
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.runtime.Composable
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import com.bwc.tul.R
import com.bwc.tul.websocket.*
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DebugLogScreen(
    logs: List<String>,
    onNavigateBack: () -> Unit,
    onExportLogs: (File) -> Unit = {}
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Debug Logs") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_69_white),
                            contentDescription = "Back"
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(logs.size) { index ->
                Card {
                    Text(
                        text = logs[index],
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(8.dp)
                    )
                }
            }
        }
    }
}
@Preview(showBackground = true)
@Composable
fun DebugLogScreenPreview() {
    ThaiUncensoredLanguageTheme {
        DebugLogScreen(
            logs = listOf(
                "[12:34:56] Connected to server",
                "[12:35:01] Received audio data (size: 1024 bytes)",
                "[12:35:02] Sent translation request",
                "[12:35:03] Received translation response",
                "[12:35:05] Disconnected from server"
            ),
            onNavigateBack = {},
            onExportLogs = {}
        )
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\view\MainScreen.kt --- 
 package com.bwc.tul.ui.view

import androidx.compose.ui.Alignment
import android.content.Context
import android.content.SharedPreferences
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.bwc.tul.data.UIState
import com.bwc.tul.ui.components.StatusBar
import com.bwc.tul.ui.theme.ThaiUncensoredLanguageTheme
import com.bwc.tul.R

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreenContent(
    onBackClick: () -> Unit,
    uiState: UIState,
    onMicClick: () -> Unit,
    onConnectDisconnect: () -> Unit,
    onSettingsClick: () -> Unit,
    onDevSettingsClick: () -> Unit
) {
    val listState = rememberLazyListState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Column {
                        Text(
                            text = stringResource(id = R.string.app_name),
                            style = MaterialTheme.typography.titleLarge
                        )
                        Text(
                            text = uiState.toolbarInfoText,
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                },
                navigationIcon = {
                    IconButton(
                        onClick = onBackClick,
                        modifier = Modifier.size(48.dp))
                        {
                            Icon(
                                painter = painterResource(id = R.drawable.ic_69_white),
                                contentDescription = "Back",
                                modifier = Modifier.size(32.dp)
                            )
                        }
                },
                actions = {
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.padding(end = 8.dp)
                    ) {
                        IconButton(
                            onClick = onSettingsClick,
                            modifier = Modifier.size(44.dp)
                        ) {
                            Icon(
                                Icons.Filled.Settings,
                                contentDescription = "Settings",
                                modifier = Modifier.size(28.dp)
                            )
                        }
                        IconButton(
                            onClick = onDevSettingsClick,
                            modifier = Modifier.size(50.dp)
                        ) {
                            Icon(
                                painter = painterResource(id = R.drawable.ic_bj),
                                contentDescription = "History",
                                modifier = Modifier.size(32.dp)
                            )
                        }
                    }
                }
            )
        },
        floatingActionButton = {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 16.dp),
                contentAlignment = Alignment.BottomCenter
            ) {
                FloatingActionButton(
                    onClick = onMicClick,
                    containerColor = if (uiState.isListening) MaterialTheme.colorScheme.error
                    else MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_stand_bj),
                        contentDescription = "Mic"
                    )
                }
            }
        },
        bottomBar = {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                // Circular connect button on the left
                IconButton(
                    onClick = onConnectDisconnect,
                    modifier = Modifier
                        .size(56.dp)
                        .align(Alignment.CenterStart),
                    colors = IconButtonDefaults.iconButtonColors(
                        containerColor = if (uiState.isConnected)
                            MaterialTheme.colorScheme.primary
                        else
                            MaterialTheme.colorScheme.secondary
                    )
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_69_black),
                        contentDescription = if (uiState.isConnected) "Disconnect" else "Connect",
                        tint = MaterialTheme.colorScheme.onPrimary
                    )
                }
                StatusBar(
                    statusText = uiState.statusText,
                    toolbarInfoText = uiState.toolbarInfoText,
                    isSessionActive = uiState.isReady,
                    onConnectDisconnect = onConnectDisconnect,
                    modifier = Modifier.align(Alignment.CenterEnd)
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (uiState.translations.isEmpty()) {
                Text(
                    text = if (uiState.isReady) "Start speaking..."
                    else "Tap 'Connect' to begin",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier
                        .align(Alignment.Center)
                        .padding(horizontal = 16.dp),
                    textAlign = TextAlign.Center
                )
            } else {
                LazyColumn(
                    state = listState,
                    reverseLayout = true,
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(uiState.translations) { item ->
                        TranslationItemComposable(item = item)
                    }
                }
            }
        }

        if (uiState.showDebugOverlay) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.BottomStart)
                    .background(Color.Black.copy(alpha = 0.5f))
                    .padding(8.dp)
            ) {
                Text(
                    text = uiState.debugLog,
                    color = Color.Green,
                    fontFamily = FontFamily.Monospace,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }

    LaunchedEffect(uiState.translations.size) {
        if (uiState.translations.isNotEmpty()) {
            listState.animateScrollToItem(0)
        }
    }
}

// Preview functions
@Preview(showBackground = true, name = "Main Screen - Disconnected Empty")
@Composable
fun MainScreenDisconnectedEmptyPreview() {
    ThaiUncensoredLanguageTheme {
        MainScreenContent(
            uiState = UIState(
                statusText = "Disconnected",
                toolbarInfoText = "Offline",
                isReady = false,
                isListening = false,
                translations = emptyList(),
                showDebugOverlay = false,
                debugLog = ""
            ),
            onMicClick = {},
            onConnectDisconnect = {},
            onSettingsClick = {},
            onDevSettingsClick = {},
            onBackClick = {},
        )
    }
}

@Preview(showBackground = true, widthDp = 120, heightDp = 240, name = "Main Screen - Connected Listening")
@Composable
fun MainScreenConnectedListeningPreview() {
    ThaiUncensoredLanguageTheme {
        MainScreenContent(
            uiState = UIState(
                statusText = "Connected. Listening...",
                toolbarInfoText = "Session active, 1 participant",
                isReady = true,
                isListening = true,
                translations = listOf(
                    TranslationItem(text = "Hello, how are you?", isUser = true),
                    TranslationItem(text = "I'm doing well, thank you!", isUser = false)
                ),
                showDebugOverlay = true,
                debugLog = "Audio processing: ON | Connection: Stable"
            ),
            onMicClick = {},
            onConnectDisconnect = {},
            onSettingsClick = {},
            onDevSettingsClick = {},
            onBackClick = {},
        )
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\ui\view\TranslationItem.kt --- 
package com.bwc.tul.ui.view // Added package declaration

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.Alignment

// Data class from existing TranslationAdapter.kt
data class TranslationItem(
    val id: String = java.util.UUID.randomUUID().toString(),
    val text: String,
    val isUser: Boolean
)

@Composable
fun TranslationItemComposable(item: TranslationItem) {
    val speakerLabel = if (item.isUser) "You said:" else "Translation:"
    val backgroundColor = if (item.isUser) MaterialTheme.colorScheme.surfaceVariant else MaterialTheme.colorScheme.primaryContainer
    val horizontalAlignment = if (item.isUser) Alignment.End else Alignment.Start

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp, horizontal = 16.dp)
            .background(color = backgroundColor, shape = MaterialTheme.shapes.medium) // Apply background and shape to the message container
            .padding(12.dp), // Padding inside the message container
        horizontalAlignment = horizontalAlignment, // Align the content within the column
        verticalArrangement = Arrangement.spacedBy(2.dp) // Space between speaker label and text
    ) {
        Text(
            text = speakerLabel,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            text = item.text,
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemUser() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "Hello, how are you?", isUser = true))
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemModel() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "สวัสดี คุณเป็นอย่างไรบ้าง", isUser = false))
    }
}
 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\util\DebugLogger.kt --- 
package com.bwc.tul.util

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.core.content.FileProvider
import com.bwc.tul.data.AppDatabase
import com.bwc.tul.data.LogDao
import com.bwc.tul.data.LogEntry
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

/**
 * A logger object that writes logs to a Room database and provides
 * functionality to export them to a file.
 */
object DebugLogger {
    private const val TAG = "DebugLogger"
    private val scope = CoroutineScope(Dispatchers.IO)
    private lateinit var logDao: LogDao

    /**
     * Initializes the DebugLogger with a LogDao instance.
     * Must be called before using logging functions.
     */
    fun initialize(context: Context) {
        logDao = AppDatabase.getDatabase(context).logDao()
    }

    /**
     * Logs a message to the Room database.
     * @param level The severity level of the log (e.g., "INFO", "DEBUG").
     * @param tag The tag for the log message.
     * @param message The content of the log message.
     */
    fun log(level: String, tag: String, message: String) {
        if (!::logDao.isInitialized) {
            Log.e(TAG, "DebugLogger not initialized. Call initialize() first.")
            return
        }

        // Use a coroutine to avoid blocking the main thread
        scope.launch {
            try {
                val logEntry = LogEntry(
                    timestamp = System.currentTimeMillis(),
                    level = level,
                    tag = tag,
                    message = message
                )
                logDao.insert(logEntry)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to write log to database", e)
            }
        }

        // Print to Logcat for real-time debugging
        val timestamp = SimpleDateFormat("HH:mm:ss.SSS", Locale.US).format(Date())
        val logcatMessage = "[$timestamp] [$level/$tag]: $message"
        when (level) {
            "ERROR" -> Log.e(tag, logcatMessage)
            "WARN" -> Log.w(tag, logcatMessage)
            else -> Log.i(tag, logcatMessage)
        }
    }

    /**
     * Clears all logs from the database.
     */
    fun clear() {
        if (!::logDao.isInitialized) {
            Log.e(TAG, "DebugLogger not initialized. Call initialize() first.")
            return
        }

        scope.launch {
            try {
                logDao.clearAll()
                log("INFO", TAG, "--- Log Cleared ---")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to clear logs from database", e)
            }
        }
    }

    /**
     * Retrieves all logs from the database, writes them to a text file,
     * and returns a content URI for sharing.
     */
    suspend fun getLogFileUri(context: Context): Uri? {
        if (!::logDao.isInitialized) {
            Log.e(TAG, "DebugLogger not initialized. Call initialize() first.")
            return null
        }

        return try {
            val allLogs = logDao.getLogs()
            val logText = buildString {
                allLogs.forEach { entry ->
                    val date = SimpleDateFormat(
                        "yyyy-MM-dd HH:mm:ss.SSS",
                        Locale.US
                    ).format(Date(entry.timestamp))
                    appendLine("[$date] ${entry.level}/${entry.tag}: ${entry.message}")
                    appendLine("-".repeat(70))
                }
            }

            val logDir = File(context.cacheDir, "logs")
            logDir.mkdirs()
            val logFile = File(logDir, "debug_log_${System.currentTimeMillis()}.txt")
            logFile.writeText(logText)

            FileProvider.getUriForFile(
                context,
                "${context.packageName}.provider",
                logFile
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error creating log file URI", e)
            null
        }
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\viewmodel\MainViewModel.kt --- 
package com.bwc.tul.viewmodel

import android.app.Application
import android.content.Context
import android.net.Uri
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.bwc.tul.audio.AudioHandler
import com.bwc.tul.audio.AudioPlayer
import com.bwc.tul.data.AppDatabase
import com.bwc.tul.data.ServerResponse
import com.bwc.tul.data.UIState
import com.bwc.tul.ui.components.Constant
import com.bwc.tul.ui.dialog.DevSettingsListener
import com.bwc.tul.ui.view.TranslationItem
import com.bwc.tul.util.DebugLogger
import com.bwc.tul.websocket.WebSocketClient
import com.bwc.tul.websocket.WebSocketConfig
import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

class MainViewModel(
    application: Application,
    private val audioHandler: AudioHandler
) : AndroidViewModel(application), WebSocketClient.WebSocketListener, DevSettingsListener {

    private val _uiState = MutableStateFlow(UIState())
    val uiState = _uiState.asStateFlow()

    private val _events = MutableSharedFlow<ViewEvent>()
    val events = _events.asSharedFlow()

    private var webSocketClient: WebSocketClient? = null
    private val gson = Gson()

    private var audioPlayer: AudioPlayer? = null
    private var sessionHandle: String? = null

    private val prefs = application.getSharedPreferences(
        "BwctransPrefs", Context.MODE_PRIVATE)

    init {
        val logDao = AppDatabase.getDatabase(application).logDao()

    }

    override fun onSettingsSaved() {
        _uiState.update { it.copy(showDevSettings = false) }
        reloadConfiguration()
        viewModelScope.launch {
            _events.emit(ViewEvent.ShowToast("Dev Settings Saved. Please reconnect."))
        }
    }

    override fun onShareLog() {
        handleEvent(UserEvent.ShareLogRequested)
    }

    override fun onClearLog() {
        handleEvent(UserEvent.ClearLogRequested)
    }

    override fun onExportLogsComplete(file: File) {
        viewModelScope.launch {
            _events.emit(ViewEvent.ExportLogsCompleted)
        }
    }

    fun handleEvent(event: UserEvent) {
        viewModelScope.launch {
            when (event) {
                UserEvent.MicClicked -> toggleRecording()
                UserEvent.ConnectClicked -> connectWebSocket()
                UserEvent.DisconnectClicked -> disconnectWebSocket()
                is UserEvent.SettingsSaved -> {
                    with(prefs.edit()) {
                        putString("api_key", event.apiKey)
                        putString("source_lang", event.sourceLang)
                        putString("target_lang", event.targetLang)
                        apply()
                    }
                    _uiState.update { it.copy(showUserSettings = false) }
                    reloadConfiguration()
                    _events.emit(ViewEvent.ShowToast("Settings Saved. Please reconnect."))
                }
                UserEvent.ShareLogRequested -> handleShareLog()
                UserEvent.ClearLogRequested -> clearDebugLog()
                UserEvent.ShowUserSettings -> _uiState.update { it.copy(showUserSettings = true) }
                UserEvent.ShowDevSettings -> _uiState.update { it.copy(showDevSettings = true) }
                UserEvent.DismissDialog -> _uiState.update { it.copy(showUserSettings = false, showDevSettings = false) }
                UserEvent.ExportLogsCompleted ->  _events.emit(ViewEvent.ShowToast("Web Socket Logs Exported"))
            }
        }
    }

    private fun connectWebSocket() {
        if (_uiState.value.isConnected) {
            logStatus("Already connecting or connected.")
            return
        }
        logStatus("Connecting...")

        viewModelScope.launch {
            val client = try {
                withContext(Dispatchers.IO) {
                    audioPlayer?.release()
                    audioPlayer = AudioPlayer()
                    val config = buildWebSocketConfig()
                    WebSocketClient(config, this@MainViewModel, getApplication())
                }
            } catch (e: Exception) {
                logError("Connection initialization failed: ${e.message}")
                null
            }

            client?.let {
                webSocketClient = it
                it.connect()
            }
        }
    }

    private fun disconnectWebSocket() {
        logStatus("Disconnecting...")
        webSocketClient?.disconnect()
        webSocketClient = null
        audioHandler.stopRecording()
        _uiState.update {
            it.copy(
                isRecording = false,
                isListening = false,
                isConnected = false,
                isReady = false,
                statusText = "Disconnected."
            )
        }
    }

    private fun toggleRecording() {
        if (!_uiState.value.isReady) {
            logError("Not ready for audio. Please wait for setup.")
            return
        }
        val newIsListening = !_uiState.value.isListening
        _uiState.update { it.copy(isListening = newIsListening) }

        if (newIsListening) {
            audioHandler.startRecording()
            logStatus("Listening...")
        } else {
            audioHandler.stopRecording()
            logStatus("Recording stopped.")
        }
    }

    fun sendAudio(audioData: ByteArray) {
        webSocketClient?.sendAudio(audioData)
        _uiState.update {
            it.copy(
                isSending = true,
                lastAudioSentTime = System.currentTimeMillis()
            )
        }
    }

    override fun onConnectionOpen() {
        logStatus("Connection open, sending setup...")
        _uiState.update { it.copy(isConnected = true, isReady = false) }
    }

    override fun onSetupComplete() {
        logStatus("Setup complete. Ready to talk.")
        _uiState.update { it.copy(isReady = true) }
        if (!_uiState.value.isListening) {
            toggleRecording()
        }
    }

    override fun onMessage(text: String) {
        // Corrected call to logger.log

        DebugLogger.log("INFO", "WebSocket", "IN: $text")
        // Removed updating the on-screen debug log, as it's now in the database
        try {
            val response = gson.fromJson(text, ServerResponse::class.java)

            if (response.goAway != null) {
                logError(
                    "Server sent goAway. Time left: ${response.goAway.timeLeft}")
                disconnectWebSocket()
                return
            }

            response.inputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, true)
            }
            response.serverContent?.inputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, true)
            }
            response.outputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, false)
            }
            response.serverContent?.outputTranscription?.text?.let { t ->
                if (t.isNotBlank()) addOrUpdateTranslation(t, false)
            }
            response.serverContent?.parts?.firstOrNull()?.inlineData?.data?.let {
                audioPlayer?.playAudio(it)
            }
            response.serverContent?.modelTurn?.parts?.firstOrNull()?.inlineData?.data?.let {
                audioPlayer?.playAudio(it)
            }
            response.sessionResumptionUpdate?.let {
                sessionHandle = if (it.resumable == true) it.newHandle else null
                _uiState.update { s ->
                    s.copy(
                        toolbarInfoText = "Session: ${sessionHandle ?: "N/A"}"
                    )
                }
                logStatus("Session handle updated. Resumable: ${it.resumable}")
            }
        } catch (e: Exception) {
            logError("Error parsing message: ${e.message}")
        }
    }

    override fun onClose(reason: String) {
        logStatus("Connection closed: $reason")
        _uiState.update {
            it.copy(
                isConnected = false, isReady = false, isListening = false)
        }
    }

    override fun onError(message: String) {
        logError("WebSocket Error: $message")
        _uiState.update {
            it.copy(
                isConnected = false, isReady = false, isListening = false)
        }
    }

    private fun addOrUpdateTranslation(text: String, isUser: Boolean) {
        _uiState.update { currentState ->
            val newItem = TranslationItem(text = text, isUser = isUser)
            val newTranslations = listOf(newItem) + currentState.translations
            currentState.copy(translations = newTranslations)
        }
    }

    private fun reloadConfiguration() {
        if (_uiState.value.isConnected) {
            disconnectWebSocket()
        }
        logStatus("Configuration reloaded. Please connect again.")
    }

    private fun handleShareLog() = viewModelScope.launch {
        DebugLogger.getLogFileUri(getApplication())?.let { uri ->
            _events.emit(ViewEvent.ShareLogFile(uri))
        } ?: _events.emit(ViewEvent.ShowToast("Log file not available."))
    }

    private suspend fun clearDebugLog() {
        DebugLogger.clear()
        // Removed on-screen log clearing, as it's deprecated
        _uiState.update { it.copy(debugLog = "") }
        _events.emit(ViewEvent.ShowToast("Debug log database cleared."))
    }

    private fun logStatus(message: String) {
        // Corrected call
        DebugLogger.log("INFO", "MainViewModel", message)
        _uiState.update { it.copy(statusText = message) }
    }

    private fun logError(message: String) {
        // Corrected call
        DebugLogger.log("ERROR", "MainViewModel", message)
        viewModelScope.launch { _events.emit(ViewEvent.ShowError(message)) }
        _uiState.update { it.copy(statusText = message) }
    }

    private fun buildWebSocketConfig(): WebSocketConfig {
        return WebSocketConfig(
            host = prefs.getString("api_host",
                "generativelanguage.googleapis.com")!!,
            modelName = prefs.getString("selected_model",
                "gemini-1.5-flash-preview-native-audio-dialog")!!,
            vadSilenceMs = prefs.getInt("vad_sensitivity_ms", 800),
            apiVersion = prefs.getString("api_version", "v1alpha")!!,
            apiKey = prefs.getString("api_key", "")!!,
            sessionHandle = sessionHandle,
            systemInstruction = Constant.SYSTEM_INSTRUCTION
        )
    }

    override fun onCleared() {
        super.onCleared()
        audioHandler.stopRecording()
        audioPlayer?.release()
        webSocketClient?.disconnect()
    }

    sealed class ViewEvent {
        data class ShowToast(val message: String) : ViewEvent()
        data class ShowError(val message: String) : ViewEvent()
        data class ShareLogFile(val uri: Uri) : ViewEvent()
        object ExportLogsCompleted: ViewEvent()
    }

    sealed class UserEvent {
        object MicClicked : UserEvent()
        object ConnectClicked : UserEvent()
        object DisconnectClicked : UserEvent()
        data class SettingsSaved(val apiKey: String, val sourceLang: String, val targetLang: String) : UserEvent()
        object ShareLogRequested : UserEvent()
        object ClearLogRequested : UserEvent()
        object ShowUserSettings : UserEvent()
        object ShowDevSettings : UserEvent()
        object DismissDialog : UserEvent()
        object ExportLogsCompleted: UserEvent()
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\viewmodel\MainViewModelFactory.kt --- 
package com.bwc.tul.viewmodel

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.bwc.tul.audio.AudioHandler

class MainViewModelFactory(
    private val application: Application,
    private val audioHandler: AudioHandler,
) : ViewModelProvider.Factory { // line 7
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MainViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return MainViewModel(application, audioHandler) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketClient.kt --- 
package com.bwc.tul.websocket

import android.util.Log
import com.google.gson.Gson
import okhttp3.*
import okio.ByteString
import java.util.concurrent.TimeUnit
import android.content.Context
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

private enum class ClientState {
    IDLE, CONNECTING, AWAITING_SETUP_COMPLETE, READY
}
data class WebSocketConfig(    val host: String,
                               val modelName: String,
                               val vadSilenceMs: Int,
                               val apiVersion: String,
                               val apiKey: String,
                               val sessionHandle: String?,
                               val systemInstruction: String
)

class WebSocketClient(
    private val config: WebSocketConfig,
    private val listener: WebSocketListener,
    private val context: Context
) {
    private var webSocket: WebSocket? = null
    private var state: ClientState = ClientState.IDLE
    private val gson = Gson()
    private val scope = CoroutineScope(Dispatchers.IO)
    private val webSocketLogger by lazy { WebSocketLogger(context) }

    private val okHttpClient = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.MILLISECONDS)
        .addInterceptor(WebSocketInterceptor(context, config.host))
        .build()

    interface WebSocketListener {
        fun onConnectionOpen()
        fun onSetupComplete() // Called when the server confirms setup.
        fun onMessage(text: String) // For all messages after setup
        fun onClose(reason: String)
        fun onError(message: String)
    }

   fun connect() {
        if (state != ClientState.IDLE) {
            Log.w("WebSocketClient", "Already connecting or connected.")
            return
        }
        state = ClientState.CONNECTING
        Log.d("WebSocketClient", "State -> CONNECTING")

        val url = HttpUrl.Builder()
            .scheme("https")
            .host(config.host)
            .addPathSegments("${config.apiVersion}/models/${config.modelName}:generateAnswer")
            .addQueryParameter("key", config.apiKey)
            .build()
			
			scope.launch {
        webSocketLogger.logStatus(url.toString(), "Attempting to connect...")
    }

        val request = Request.Builder().url(url).build()
        webSocket = okHttpClient.newWebSocket(request, SocketListener(url.toString()))
    }

    fun sendAudio(data: ByteArray) {
        if (state != ClientState.READY) {
            Log.w("WebSocketClient", "Not ready to send audio yet.")
            return
        }
        webSocket?.send(ByteString.of(*data))
        webSocket?.request()?.url?.toString()?.let { url ->
            scope.launch {
                webSocketLogger.logSentMessage(url, "[AUDIO DATA of size ${data.size}]")
            }
        }
    }

    fun disconnect() {
        state = ClientState.IDLE
        webSocket?.close(1000, "User disconnected")
        webSocket = null
    }

    private inner class SocketListener(private val url: String) : okhttp3.WebSocketListener() {
        override fun onOpen(ws: WebSocket, response: Response) {
            scope.launch { webSocketLogger.logReceivedMessage(url, "Connection Opened: ${response.code}") }
            listener.onConnectionOpen()
            sendSetupMessage(ws)
        }

        override fun onMessage(ws: WebSocket, text: String) {
            scope.launch { webSocketLogger.logReceivedMessage(url, text) }
            if (state == ClientState.AWAITING_SETUP_COMPLETE) {
                if (text.contains("\"setupComplete\"")) {
                    Log.d("WebSocketClient", "State -> READY")
                    state = ClientState.READY
                    listener.onSetupComplete()
                } else {
                    Log.w("WebSocketClient",
                        "Received unexpected message during setup: $text")
                }
            } else {
                listener.onMessage(text)
            }
        }

        override fun onClosing(ws: WebSocket, code: Int, reason: String) {
            state = ClientState.IDLE
            scope.launch { webSocketLogger.logReceivedMessage(url, "Closing: $code / $reason") }
            listener.onClose(reason)
        }

        override fun onFailure(ws: WebSocket, t: Throwable, response: Response?) {
            state = ClientState.IDLE
            scope.launch { webSocketLogger.logError(url, "Failure: ${t.message}", t.stackTraceToString()) }
            listener.onError(t.message ?: "Unknown WebSocket error")
        }
    }

    private fun sendSetupMessage(ws: WebSocket) {
        state = ClientState.AWAITING_SETUP_COMPLETE
        Log.d("WebSocketClient", "State -> AWAITING_SETUP_COMPLETE")
        val setupMessage = mapOf("setup" to mutableMapOf<String, Any>().apply {
            put("model", "models/${config.modelName}")
            put("generationConfig", mapOf("responseModalities" to listOf("AUDIO")))
            put("systemInstruction",
                createSystemInstruction(config.systemInstruction))
            put("inputAudioTranscription", emptyMap<String, Any>())
            put("outputAudioTranscription", emptyMap<String, Any>())
            put("contextWindowCompression",
                mapOf("slidingWindow" to emptyMap<String, Any>()))
            put("realtimeInputConfig", mapOf(
                "automaticActivityDetection" to mapOf(
                    "silenceDurationMs" to config.vadSilenceMs)
            ))
            config.sessionHandle?.let { handle ->
                put("sessionResumption", mapOf("handle" to handle))
            }
        })
        val setupJson = gson.toJson(setupMessage)
        Log.d("WebSocketClient", "Sending setup message...")
        ws.send(setupJson)
        scope.launch { webSocketLogger.logSentMessage(ws.request().url.toString(), setupJson) }
    }

    private fun createSystemInstruction(instruction: String): Map<String, Any> {
        return mapOf(
            "parts" to instruction.split(Regex("\n\n+")).map {
                mapOf("text" to it.trim())
            }
        )
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketInterceptor.kt --- 
package com.bwc.tul.websocket

import android.content.Context
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import okhttp3.Interceptor
import okhttp3.Response
import okio.IOException
class WebSocketInterceptor(
    private val context: Context,
    private val baseUrl: String
) : Interceptor {
    private val logger = WebSocketLogger(context)
    private val scope = CoroutineScope(Dispatchers.IO)

    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        scope.launch {
            logger.logSentMessage(request.url.toString(), "--> HTTP Upgrade Request: ${request.method} ${request.url}\n${request.headers}")
        }

        val response: Response
        try {
            response = chain.proceed(request)
        } catch (e: IOException) {
            scope.launch { logger.logError(request.url.toString(), "<-- HTTP Upgrade FAILED", e.stackTraceToString())}
            throw e
        }

        scope.launch {
            if (isWebSocketUpgrade(response)) {
                logger.logStatus(request.url.toString(), "<-- HTTP Upgrade Response: ${response.code} ${response.message}\n${response.headers}")
            } else {
                logger.logError(request.url.toString(), "<-- Non-websocket response", "Code: ${response.code}\nHeaders: ${response.headers}")
            }
        }
        return response
    }

    private fun isWebSocketUpgrade(response: Response): Boolean {
        return response.code == 101 &&
                response.header("Connection")?.equals("Upgrade", ignoreCase = true) == true &&
                response.header("Upgrade")?.equals("websocket", ignoreCase = true) == true
    }

    fun shutdown() {
        scope.coroutineContext.cancel()
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketLogExporter.kt --- 
 package com.bwc.tul.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import com.bwc.tul.websocket.WebSocketLogger
import kotlinx.coroutines.launch
import java.io.File

@Composable
fun WebSocketLogExporter(
    modifier: Modifier = Modifier,
    onExportComplete: (File) -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    var isExporting by remember { mutableStateOf(false) }

    Button(
        onClick = {
            isExporting = true
            scope.launch {
                val file = WebSocketLogger(context).exportLogs()
                onExportComplete(file)
                isExporting = false
            }
        },
        modifier = modifier,
        enabled = !isExporting
    ) {
        if (isExporting) {
            CircularProgressIndicator(Modifier.size(ButtonDefaults.IconSize))
            Spacer(Modifier.width(8.dp))
            Text("Exporting...")
        } else {
            Text("Export WebSocket Logs")
        }
    }
} 
--- File: D:\ANDROID\Projects\TUL\app\src\main\java\com\bwc\tul\websocket\WebSocketLogger.kt --- 
package com.bwc.tul.websocket


import android.content.Context
import com.bwc.tul.data.AppDatabase
import com.bwc.tul.data.websocket.WebSocketLogEntry
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.File
import java.util.*


class WebSocketLogger(private val context: Context) {
    private val dao = AppDatabase.getDatabase(context).webSocketLogDao()

    suspend fun logSentMessage(url: String, message: String) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.SENT,
                url = url,
                message = message
            )
        )
    }

    suspend fun logReceivedMessage(url: String, message: String) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.RECEIVED,
                url = url,
                message = if (isAudioMessage(message)) "[AUDIO DATA]" else message
            )
        )
    }

    suspend fun logStatus(url: String, message: String) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.STATUS,
                url = url,
                message = message
            )
        )
    }

    suspend fun logError(url: String, message: String, error: String?) = withContext(Dispatchers.IO) {
        dao.insert(
            WebSocketLogEntry(
                direction = WebSocketLogEntry.Direction.ERROR,
                url = url,
                message = message,
                isError = true,
                errorMessage = error
            )
        )
    }

    suspend fun getLogs(limit: Int = 200): List<WebSocketLogEntry> = withContext(Dispatchers.IO) {
        dao.getRecentLogs(limit)
    }

    suspend fun exportLogs(): File = withContext(Dispatchers.IO) {
        val logs = dao.getAllLogs()
        val file = File(context.cacheDir, "websocket_logs_${System.currentTimeMillis()}.txt")

        file.writeText(buildString {
            logs.forEach { log ->
                appendLine("[${Date(log.timestamp)}] ${log.direction} ${log.url}")
                if (log.isError) {
                    appendLine("ERROR: ${log.errorMessage}")
                }
                appendLine(log.message)
                appendLine("=".repeat(80))
            }
        })
        file
    }

    private fun isAudioMessage(message: String): Boolean {
        return try {
            if (message.startsWith("{")) {
                val json = JSONObject(message)
                json.has("audio") || json.optString("contentType").contains("audio", ignoreCase = true)
            } else {
                message.contains("content-type: audio", ignoreCase = true)
            }
        } catch (e: Exception) {
            false
        }
    }
} 
